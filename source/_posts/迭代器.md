---
title: 迭代器
date: 2023-04-20 10:20:24
tags:
---

#### 迭代与循环的区别

迭代是在一个有序集合上 按顺序反复多次执行一段程序，通常会有明确的终止条件，不保证会把所有数据都取完。
循环是迭代的基础，因为循环是在指定迭代次数内反复执行某段特定的代码，往往没有明确的终止条件，通常会遍历所有数据。

```javascript
let collection = ["foo", "bar", "baz"];
for (let index = 0; index < collection.length; ++index) {
  console.log(collection[index]);
}
// 上述使用for循环来执行针对一个数组的遍历，数组作为最常见的有序集合，使用for循环 可能通过索引的递增来实现对数组元素每一项的访问。
// 同时 也暴露出使用循环的两个痛点：
// 1.在进行循环之前需要知道如何使用数据结构。例如上述循环的数组，是先访问数组引用然后通过一直递增的index进行访问对应位置元素的，
// 2.遍历顺序并不是数据结构固有的。上述的数组是一个有序集合，但js中还有一个数据结构并不是都是有序的。
```

#### 迭代器模式

迭代器模式是指 在 js 中可以把某些结构称为<b>可迭代对象</b>（因为它们实现了正式的 Iterable 接口），而且可以通过迭代器 Iterator 进行消费。

可迭代对象：是一种抽象的说法。通常可以把数组和集合这样的集合类型的对象称为可迭代对象。通常这样的类型<b>包含的元素都是有限的，并且都具有无歧义的遍历顺序,但是，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构。</b>

迭代器：迭代器是按需创建的一次性对象，每个迭代器都是关联一个可迭代对象，而迭代器会暴露其关联的可迭代对象的 api。所以迭代器无须了解与其关联的可迭代对象本身的结构，只需要知道如何取得连续的值。

#### 可迭代协议 (实现 Iterable 接口)

可迭代协议要求同时具备两种能力：支持迭代的自我识别能力和能够创建实现<b>迭代器</b>（也是 Iterator 接口的对象）的能力。
在 js 中，根据上述可知要是一个结构想具备可迭代协议，也就是说想成为一个可迭代对象的话，就必须暴露一个属性作为<b>默认迭代器</b>，而且这个属性必须要使用特殊的`Symbol.iterator`作为键，这个默认迭代器的属性必须引用一个迭代器的工厂函数，调用这个迭代器的工厂函数必须返回一个新的迭代器。
目前 js 中内置类型 实现了 Iterable 接口的如下：

- 字符串
- 数组
- 映射（Map）
- 集合（Set）
- arguments 对象
- NodeList 等 DOM 集合类型

检查是否存在默认迭代器属性可以暴露这个工厂函数

```javascript
let num = 1;
let obj = {};
// 这两种类型没有实现迭代器工厂函数
console.log(num[Symbol.iterator]); // undefined
console.log(obj[Symbol.iterator]); // undefined

let str = "abc";
let arr = ["a", "b", "c"];
// 这些类型都实现了迭代器工厂函数
console.log(str[Symbol.iterator]); // f values() { [native code] }
console.log(arr[Symbol.iterator]); // f values() { [native code] }

// 调用这个工厂函数会生成一个迭代器
console.log(str[Symbol.iterator]()); // StringIterator {}
// 实际在写的时候，不需要显式调用这个工厂函数来生成迭代器。
```

实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。在 js 中 可迭代对象的语言特性包括：

- for...of 循环
- 数组解构
- 扩展操作符
- Array.from()
- 创建集合
- 创建映射
- promise.all()接收由 promise 组成的可迭代对象
- promise.race()接收由 promise 组成的可迭代对象
- yield<sup>\*</sup> 操作符，在生成器中使用

> 这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器
> 如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口

#### 迭代器协议
