[{"title":"开发问题记录","url":"/blog/2023/03/23/开发问题记录/","content":"\n### html2Canvas 生成海报---图片跨域\n\n#### 问题描述和要点\n\n    - 使用html2Canvas生成海报的时候，出现图片提示跨域无法展示的问题，经过第一次百度过后，发现需要设置img标签crossOrigin属性`crossOrigin=\"anonymous\" `，接着设置html2canvas的参数`useCORS: true`。\n    - 本以为很简单就可以解决的时候，发布到线上环境，才发现这个坑远不止这么简单，单单设置这两个属性和参数还无法解决图片跨域问题，在经过又一番百度，发现一种解释刚好符合我现在遇到问题的情况。\n    1. 原来是因为在html中img标签能正常进行图片访问，并且通过 <img> 加载的图片，浏览器默认情况下会将其缓存起来。\n    2. 但html2Canvas在生成海报接受dom传入的时候，代码中创建的 <img> 再去访问同一个图片时，浏览器就不会再发起新的请求，而是直接访问缓存的图片。但是由于 JS 中的 <img> 同样也是设置了 crossorigin，也就意味着它将要以 CORS 的方式请求，但缓存中的图片显然不是的，所以浏览器直接就拒绝了。当我们在浏览器network面板勾选disable cache 选项，就会不从缓存中进行图片访问 就可以正常展示图片了。\n\n#### 问题解决\n\n     因为js创建的img标签是以访问缓存的方式去展示图片的，所以在html2Canvas渲染的时候，我就想不让其通过缓存去访问，那么每一次访问图片路径地址都需要是一个不相同的地址。所以我就采用了很暴力的办法，就是在图片路径后面直接进行时间戳参数的拼接`?t=${new Date().getTime()}`,这样就保证了每一次图片访问都会进行跨域请求。\n","tags":["问题记录"]},{"title":"vue-quill-editor基本使用","url":"/blog/2023/03/22/vue-quill-editor基本使用/","content":"\n##### Quill.js 富文本（vue-quill-editor）\n\n最近在做一个富文本编辑器，在网上对比找了一圈，选择了[Quill.js](https://www.kancloud.cn/liuwave/quill/1409423)，这是一款偏向底层，易于扩展的富文本编辑器，但是对于新手不太友好，目前来说这个库我自己也没有进行深入的使用和研究，因为目前项目主要以 vue 的为主，所以这次选择了对这个库进行过二次封装的[vue-quill-editor](https://github.com/surmon-china/vue-quill-editor)组件。不过在这次的使用也遇到一些问题。在这里记录一下\n\n###### 1.安装 vue-quill-editor\n\n```javascript\nnpm install vue-quill-editor --save\n```\n\n###### 2.针对 vue-quill-editor 在进行组件的二次封装\n\nvue-quill-editor 封装中的说明：\n\n1.在样式中对原有样式中有英文描述的使用中文进行覆盖\n\n2.引入组件的同时 需要将 quill 的样式文件也进行引入\n\n```javascript\n<template>\n  <div>\n    <quill-editor\n      class=\"editor\"\n      :content=\"content\"\n      :options=\"editorOption\"\n      ref=\"myQuillEditor\"\n      @change=\"onEditorChange($event)\"\n    >\n    </quill-editor>\n  </div>\n</template>\n<script>\nimport \"quill/dist/quill.core.css\";\nimport \"quill/dist/quill.snow.css\";\nimport \"quill/dist/quill.bubble.css\";\nimport { quillEditor } from \"vue-quill-editor\";\n\nconst toolbarOptions = [\n  [\"bold\", \"italic\", \"underline\", \"strike\"], // 加粗 斜体 下划线 删除线\n  [\"blockquote\", \"code-block\"], // 引用  代码块\n  [{ header: 1 }, { header: 2 }], // 1、2 级标题\n  [{ list: \"ordered\" }, { list: \"bullet\" }], // 有序、无序列表\n  [{ script: \"sub\" }, { script: \"super\" }], // 上标/下标\n  [{ indent: \"-1\" }, { indent: \"+1\" }], // 缩进\n  // [{'direction': 'rtl'}],                         // 文本方向\n  [{ size: [\"small\", false, \"large\", \"huge\"] }], // 字体大小\n  [{ header: [1, 2, 3, 4, 5, 6, false] }], // 标题\n  [{ color: [] }, { background: [] }], // 字体颜色、字体背景颜色\n  [{ font: [] }], // 字体种类\n  [{ align: [] }], // 对齐方式\n  [\"clean\"], // 清除文本格式\n  [\"link\", \"image\", \"video\"], // 链接、图片、视频\n]; //工具菜单栏配置\n\nexport default {\n  props:{\n    content: {\n      type: String,\n      default: ''\n     }\n   },\n  components: {\n    quillEditor,\n  },\n  data() {\n    return {\n      editorOption: {\n        modules: {\n          toolbar: {\n            container: toolbarOptions,\n            handlers: {},\n          },\n        },\n        placeholder: \"请输入内容......\",\n        readOnly: false,\n        theme: \"snow\", //主题 snow/bubble\n      },\n    };\n  },\n  methods: {\n    // 富文本组件change事件\n    onEditorChange({ quill, html, text }) {\n      this.$emit(\"editorChange\", html);\n    },\n  },\n};\n</script>\n<style lang=\"scss\">\n.editor {\n  line-height: normal !important;\n  height: 590px;\n  .ql-container {\n    height: 500px !important;\n    border: 1px solid #ebebeb !important;\n    border-bottom-left-radius: 4px;\n    border-bottom-right-radius: 4px;\n    border-top: 0 !important;\n  }\n  .ql-toolbar {\n    border: 1px solid #ebebeb !important;\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n  }\n  .ql-snow .ql-tooltip[data-mode=\"video\"] {\n    left: 112px !important;\n  }\n  .ql-snow .ql-tooltip[data-mode=\"video\"]::before {\n    content: \"请输入视频地址:\";\n  }\n  .ql-tooltip[data-mode=\"link\"]::before {\n    content: \"请输入链接地址:\";\n  }\n  .ql-snow .ql-tooltip[data-mode=\"link\"] {\n    left: 112px !important;\n  }\n  .ql-formats {\n    > .ql-picker.ql-size {\n      .ql-picker-label::before {\n        content: \"14px\";\n      }\n      .ql-picker-item::before {\n        content: \"14px\";\n      }\n      .ql-picker-label[data-value=\"small\"]::before {\n        content: \"10px\";\n      }\n      .ql-picker-item[data-value=\"small\"]::before {\n        content: \"10px\";\n      }\n      .ql-picker-label[data-value=\"large\"]::before {\n        content: \"18px\";\n      }\n      .ql-picker-item[data-value=\"large\"]::before {\n        content: \"18px\";\n      }\n      .ql-picker-label[data-value=\"huge\"]::before {\n        content: \"32px\";\n      }\n      .ql-picker-item[data-value=\"huge\"]::before {\n        content: \"32px\";\n      }\n    }\n    > .ql-picker.ql-header {\n      .ql-picker-label::before {\n        content: \"文本\";\n      }\n      .ql-picker-item::before {\n        content: \"文本\";\n      }\n      .ql-picker-label[data-value=\"1\"]::before {\n        content: \"标题1\";\n      }\n      .ql-picker-item[data-value=\"1\"]::before {\n        content: \"标题1\";\n      }\n      .ql-picker-label[data-value=\"2\"]::before {\n        content: \"标题2\";\n      }\n      .ql-picker-item[data-value=\"2\"]::before {\n        content: \"标题2\";\n      }\n\n      .ql-picker-label[data-value=\"3\"]::before {\n        content: \"标题3\";\n      }\n      .ql-picker-item[data-value=\"3\"]::before {\n        content: \"标题3\";\n      }\n\n      .ql-picker-label[data-value=\"4\"]::before {\n        content: \"标题4\";\n      }\n      .ql-picker-item[data-value=\"4\"]::before {\n        content: \"标题4\";\n      }\n      .ql-picker-label[data-value=\"5\"]::before {\n        content: \"标题5\";\n      }\n      .ql-picker-item[data-value=\"5\"]::before {\n        content: \"标题5\";\n      }\n      .ql-picker-label[data-value=\"6\"]::before {\n        content: \"标题6\";\n      }\n      .ql-picker-item[data-value=\"6\"]::before {\n        content: \"标题6\";\n      }\n    }\n    > .ql-picker.ql-font {\n      .ql-picker-label::before {\n        content: \"标准字体\";\n      }\n      .ql-picker-item::before {\n        content: \"标准字体\";\n      }\n      .ql-picker-label[data-value=\"serif\"]::before {\n        content: \"衬线字体\";\n      }\n      .ql-picker-item[data-value=\"serif\"]::before {\n        content: \"衬线字体\";\n      }\n      .ql-picker-label[data-value=\"monospace\"]::before {\n        content: \"等宽字体\";\n      }\n      .ql-picker-item[data-value=\"monospace\"]::before {\n        content: \"等宽字体\";\n      }\n    }\n  }\n}\n</style>\n```\n\n###### 3.图片上传方法的重写\n\n原因：编辑器本身是可以进行图片上传的 不过上传的图片都是转换成 base64 放上去的。这样会导致整个编辑器输出的 html 文本过大， 提交后台接口失败。\n\n解决方法：让用户在使用上传图片的时候 直接将图片上传到服务器 然后使用返回的 url 链接放入富文本的内容中 ，因为我当前 vue 项目是使用 element 组件库 所以下面选择使用 element 中的 upload 组件 进行辅助上传\n\n- 组件内使用 element upload 组件\n\n  ```javascript\n  <template>\n    <div>\n      <!-- 使用element图片上传组件 将其隐藏主要用于辅助富文本组件上传图片 -->\n      <el-upload\n        class=\"editor-uploader\"\n        :action=\"uploadPath\"\n        :multiple=\"false\"\n        :show-file-list=\"false\"\n        :on-success=\"uploadSuccess\"\n        :before-upload=\"beforeUpload\"\n        v-show=\"false\"\n      >\n      </el-upload>\n      <quill-editor\n        class=\"editor\"\n        :content=\"content\"\n        :options=\"editorOption\"\n        ref=\"myQuillEditor\"\n        @change=\"onEditorChange($event)\"\n      >\n      </quill-editor>\n    </div>\n  </template>\n  ```\n\n- 使用 handlers 重写图片上传方法，定义编辑器中图片上传按钮事件\n\n  ```javascript\n   handlers: {\n      image: (value) => {\n         if (value) {\n            // 调用 element 上传组件\n            document.querySelector(\".editor-uploader input\").click();\n           } else {\n            this.quill.format(\"image\", false);\n             }\n       },\n    },\n  ```\n\n- 图片上传组件的拦截方法实现和成功后的写入操作\n\n  ```javascript\n     //图片上传之前限制\n      beforeUpload(file) {\n        const isImage = file.type.indexOf(\"image/\") > -1;\n        const isLt1M = file.size / 1024 / 1024 < 1;\n        if (!isImage) {\n          this.$message.error(\"仅支持上传图片!\");\n        } else if (!isLt1M) {\n          this.$message.error(\"请将图片大小控制在1MB内!\");\n        }\n        return isImage && isLt1M;\n      },\n      //图片上传成功\n      uploadSuccess(res, file, fileList) {\n        // 获取富文本示例\n        let quill = this.$refs.myQuillEditor.quill;\n        if (res.flag) {\n          // 获取光标所在的位置\n          let length = quill.getSelection().index;\n          // 插入图片\n          quill.insertEmbed(length, \"image\", res.data.url);\n          // 调整光标在图片之后\n          quill.setSelection(length + 1);\n        } else {\n          this.$message.error(\"图片上传失败！\");\n        }\n      },\n  ```\n\n###### 4.图片缩放处理\n\n- 安装富文本编辑器内图片缩放模块\n\n```javascript\nnpm install quill-image-resize-module --save\n```\n\n- 引入图片缩放模块\n\n```javascript\nimport { quillEditor, Quill } from \"vue-quill-editor\";\n\n// 引入图片缩放模块 并注册到Quill上\nimport ImageResize from \"quill-image-resize-module\";\nQuill.register(\"modules/imageResize\", ImageResize);\n```\n\n- 在 vue-quill-editor 配置中模块下 加入缩放模块\n\n```javascript\n  editorOption: {\n        modules: {\n          // 图片缩小放大插件配置\n          imageResize: {\n            displaySize: true,\n          },\n         // ...省略其他配置\n      },\n```\n\n使用图片缩放模块的注意点，在使用过程中遇到了一个报错，发现是还需要在 webpack 中加入配置 该模块才可以引入成功 继而正常使用\n\n报错问题 **<mark>Cannot read property 'imports' of undefined\"</mark>**\n\n1. 使用 webpack 打包的项目\n\n在 build 文件夹下找到 webpack.base.conf.js 文件 在 plugins 中加入如下代码\n\n```javascript\n//若文件中未引入 webpack 则需\nconst webpack = require(\"webpack\");\n\n// 在webpack插件中引入Quill.js文件\nplugins: [\n  new webpack.ProvidePlugin({\n    \"window.Quill\": \"quill/dist/quill.js\",\n    Quill: \"quill/dist/quill.js\",\n  }),\n];\n```\n\n2.使用 vue-cli 脚手架搭建的项目\n\n在 vue.config.js 中进行设置\n\n```javascript\n//若文件中未引入 webpack 则需\nconst webpack = require(\"webpack\");\n\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.plugin(\"provide\").use(webpack.ProvidePlugin, [\n      {\n        \"window.Quill\": \"quill/dist/quill.js\",\n        Quill: \"quill/dist/quill.js\",\n      },\n    ]);\n  },\n};\n```\n","tags":["vue工具"]},{"title":"Linux命令记录","url":"/blog/2023/03/21/Linux命令记录/","content":"\n> 在使用 mac 进行前端开发过程中，由于没有接触过 linux 操作系统，对 mac 的操作命令很是生疏。\n> 在使用过程遇到的 linux 命令在此进行记录总结\n\n- 查看配置网络设备<br>\n  `ifconfig`\n- 查看端口占用情况<br>\n  `sudo losf -i tcp:端口号`\n- 杀死指定端口<br>\n  `kill -9 pid` (pid-为查询出端口号展示出来的 pid)\n","tags":["Linux"]},{"title":"基本引用类型","url":"/blog/2023/03/02/基本引用类型/","content":"\n### 基本引用类型\n\n​ 引用值（或者对象）是某个特定引用类型的实例。\n\n​ 引用类型是把数据和功能组织到一起的结构。引用类型有时候也被称为是对象定义，因为他们描述了自己的对象应有的属性的方法。\n\n​ 新对象通过 new 操作符后跟一个构造函数来创建 例如：\n\n```javascript\nlet now = new Date();\n// 上面 now这个变量保存的就是通过 new操作符 来创建的一个Date引用类型的实例\n```\n\n#### 1.Date\n\n​ `let now = new Date()` 使用 new 操作符来调用 Date 构造函数创建一个日期对象\n\n​ 上述创建的日期对象保存的是当前的日期和时间。\n\n​ 如果需要基于其他时间进行创建 则需要将时间毫秒表示的参数传给 Date 构造函数，参数也可以是`Date.parse()`方法支持的日期格式，因为在 Date 构造函数会隐式调用`Date.parse()`,如果传入错误的参数 将会返回 NaN。\n\n​ `Date.UTC()`也是一个基于其他时间创建日期对象的一个方法。但是传入的参数很特殊，需要传入年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0 ～ 23）、分、秒和毫秒。其中年、月为必填，其他参数没填 日默认为 1，剩余参数默认为 0。`Date.UTC()`也支持隐式调用，但是隐式调用返回的是本地日期，相反则返回的是 GMT 日期。该方法使用如下\n\n```javascript\n// GMT时间 2000年1月1日零点\nconst dateUtc = new Date(Date.UTC(2000, 0));\n\n// GMT时间 2005年5月5日17时55分55秒\nconst dateUtc2 = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));\n\n// 本地时间 2000年1月1日零点\nconst dateUtc = new Date(2000, 0);\n```\n\n​ `Date.now()`方法返回执行时日期和时间的毫秒数 也就是时间戳\n\n​ 引用类型还重写了`toLocaleString()、toString()、valueOf()`方法\n\n#### 2.RegExp\n\n#### 3.原始值包装类型\n\n​ 原始值包装类型：js 针对 Number,String,Boolean 三个类型的原始值, 提供的特殊引用类型。这三种类型有引用类型的一些基本特点，也有原始类型对应的特殊行为。\n\n​ 1.在用到某个原始值的方法或者属性的时候，后台会自动创建一个相应的原始包装类型的对象，会执行如下三步操作\n\n​ 1）创建一个原始值包装类型的实例\n\n​ 2）调用实例上的特定方法\n\n​ 3）销毁实例\n\n​ 2.引用类型与原始值包装类型的主要区别: 对象的生命周期，自动创建的原始值包装对象只存在于访问他的那行代码，过后就会被销毁。 而通过 new 实例化引用类型后，其生命周期会在离开作用域时被销毁。\n\n​ 3.在原始值包装类型的实例上调用 typeof 返回 ‘object’\n\n##### Boolean\n\n​ 1.创建一个 Boolean 对象示例 需要在 Boolean 构造函数传入 true 或者 false\n\n​ `let booleanObject = new Boolean(true)`\n\n​ 2.Boolean 对象生成的实例 重写了 valueOf()方法，返回原始值 true 或者 false，toString()方法 返回'true'或'false'，生成的实例类型是 obejct，所以在进行布尔表达式转换的时候 不管生成实例传入的是 true 或 false 都会返回 true，所以要减少 Boolean 对象的使用。\n\n##### Number\n\n​ 1.创建一个 Number 对象，就使用 Number 构造函数并传入一个数值\n\n​ `const numberObject = new Number(10)`\n\n​ 2.Number 类型重写了 valueOf()，toString()，toLocalString()方法，其中除了 valueOf 返回原始数值外，另外两个方法皆返回数值字符串。\n\n​ 3.toFixed() 接受一个参数，表示结果中小数的位数，返回包含指定小数点位数的数值字符串。（toFixed()方法支持 0 ～ 20 个小数位的数值）\n\n​ `let num=10; console.log(num.toFixed(2)); //'10.00'`\n\n​ toExponential()方法返回以科学记数法表示的数值字符串，传参与 toFixed()相同\n\n​ `let num = 10; console.log(num.toExponential(1)); // '1.0e+1'`\n\n​ toPrecision()方法 会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法，接受一个参数，表示结果中数字的总位数（不包含指数）\n\n```javaScript\nlet num = 99\nconsole.log(num.toPrecision(1));//\"1e+2\"\nconsole.log(num.toPrecision(2)); // '99'\nconsole.log(num.toPrecision(3));//'99.0'\n```\n\n​ 4.使用原始值包装类型创建出来的 Number 实例----类型是 'object';\n\n​ 5.isInteger()方法用于判别一个数值是否保存为整数。小数位的值全都是 0 的情况下 也是一个整数\n\n​ `console.log(Number.isInteger(1.00)) //true`\n\n##### String\n\n​ 1.创建一个 String 对象，使用 String 构造函数并传入一个字符串\n\n​ `let stringobject = new String('hello world');`\n\n​ 2.length 属性：String 对象的 length 属性 表示字符串中字符的数量，其中字符串中包含双字节字符(而不是单字节的 ASCII 字符)，也仍然会按照单字符来计数。\n\n​ 3.javaScript 字符：js 的字符串是由 16 位码元组成。所以字符串的 length 属性就表示字符串包含多少 16 位码元。\n\n​ charAt()方法 接受一个整数参数，查找指定索引位置的 16 位码元 并返回对应的字符。\n\n​ charCodeAt()方法 接受一个整数参数 返回指定索引位置的码元值。\n\n​ fromCharCode()方法 用于根据给定的 utf-16 码元创建字符串中的字符，可以接受任意多个数值 返回将多个数值对应的字符拼接起来形成的字符串。\n\n​ 代理对：16 位只能唯一表示 65536 个字符，超出无法使用 16 位码元进行表示。但是 Unicode 采取 每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的方法就叫做代理对。\n\n​ codePointAt() 用于正确解析包含单码元字符又包含代理对字符串的字符串。传入一个整数参数 代表指定查询字符串的索引位置，返回对应位置的正确的码点。但是针对代理对 需要传入代理对开头的索引位置 才能查看该代理对正确的码点。\n\n​ fromCodePoint()方法 同 formCharCode()传参和返回值一样,但可以解析代理对的码点 返回正确的字符串。\n\n​ 4.字符串的操作方法\n\n​ concat()方法 接受任意多个参数，<b>返回拼接完成的新字符串，不会修改调用他的字符串。</b>在字符串中使用“+”号拼接字符串更为常见。\n\n​ slice()方法返回操作字符串的一个子字符串，不会修改调用他们的字符串。接受两个参数，第一个参数表示字符串开始的位置（必填参数），第二个参数<b>表示字符串结束的位置，返回的子字符串不包含结束位置的字符，第二个参数可以省略，省略第二个参数意味着提取到字符串末尾。</b>当参数为负值的时候，slice()会用字符串长度加上参数，然后进行方法调用，也可以说为第一个参数为负数的时候，是从字符串右边开始截取。\n\n​ substr()方法与上方方法返回结果一致 接受参数数量一致，同样第二个参数也可以省略，<b>但第二个参数表示返回的字符串数量。</b>substr()将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。\n\n​ substring()方法与上述两个方法返回结果一致，接受参数数量一致，第二个参数功能与 slice()方法一致，但当参数出现负数的时候，会将负数参数都转为 0 然后进行方法执行。并且<b>该方法始终以小参数作为起点，大参数作为终点的。</b>\n\n​ indexOf()和 lastIndexOf()方法。都是从字符串中搜索传入的字符，返回字符对应的位置，并且都是找到第一个符合要求的字符就返回位置。(没查询到，则返回-1)。<b>两者的区别在于，indexOf()从头到尾进行查找，而 lastIndexOf()则是从尾部到头部进行查找。</b> 上面两个方法都可以接收一个可选的第二个参数，表示开始搜索的位置。<b>所以 indexOf()将会从指定位置开始向尾部进行搜索(忽略该指定位置之前的参数)，而 lastIndexOf()则会从指定位置开始从尾部向头部进行搜索(忽略该指定位置之后直到末尾的参数)。</b>\n\n​ startsWith()：用于从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。第一个参数为字符串必填参数，<b>传入后从索引为 0 开始搜索，搜索字符长度为传入字符串的长度。</b>接受第二个可选的参数，表示开始搜索的位置，忽略该位置之前的字符，但搜索范围同样是传入字符串的长度。\n\n​ includes()：接受参数与返回值与上方方法一致。<b>不同的是 includes 搜索范围是整个字符串。</b>\n\n​ endsWith()：接受参数与返回值与上方方法一致。搜索范围也与传入字符串长度有关。<b>但不同的是该方法检查开始与索引(string.length - substring.length)的匹配项。也就说检查开始与字符串长度减去传入字符串长度的索引位置。</b>也可以接收第二个可选的参数，<b>传入的第二个参数就代表字符串的总长度。所以会改变检查开始位置。</b>\n\n​ trim()：该方法会创建一个字符串副本，删除前，后所有空格符，再返回结果。返回的是一个字符串副本，愿字符串不受影响。trimLeft()、trimRight()分别清空字符串左右的空格。\n\n​ repeat()：这个方法接受一个整数参数，表示要将字符串复制多少次，然后拼接返回副本后的结果。\n\n​ `const stringValue = 'na';console.log(stringValue.repeat(16)); //nananananananananan...`\n\n​ padSatrt()和 padEnd()方法会复制字符串，小于指定长度，分别在左右填充字符，直至满足指定长度。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格。<b>第二个参数不限于一个字符 多个字符的字符串，会将其拼接并截断以匹配指定长度。如果第一个参数指定的长度小于或等于字符串长度，则返回原始字符串。</b>\n\n​ 字符串的迭代与解构：字符串在原型上暴露了一个@@iterator 方法。表示可以迭代字符串的每个字符。可以使用 for...of...进行循环，也可以通过解构操作符来进行解构。\n\n`let message = 'abcde';console.log([...message])//['a','b','c','d','e']`\n\n#### 4.单例内置对象\n\n##### Global\n\n​ Global 对象是 js 中最特别的对象，因为代码不会显式访问它。Global 对象是一种兜底对象，所针对的是不属于任何对象的属性和方法。在全局作用域中定义的变量和函数都会变成 Global 对象的属性。\n\n​ URL 编码方法\n\n​ encodeURI()：用于编码统一资源标识符。该方法在编码过程中不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号。所以该方法一般用于对整个 URL 进行编码。\n\n​ encodeURIComponent()：同样用于编码统一资源标识符。该方法会编码他发现的所有非标准字符。一般用于编码 URL 后面拼接的字符串。\n\n​ decodeURI()：仅对 encodeURI 编码后的字符进行解码。\n\n​ decodeURIComponent()：仅对 encodeURIComponent()编码后的字符进行解码。\n\n​ eval()：接受一个参数，是一个要执行的 js 字符串。\n\n```javascript\neval(\"console.log('hi')\");\n//等价于\nconsole.log(\"hi\");\n```\n\n1. 通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。\n2. 通过 eval()定义的任何变量和函数都不会被提升，解析代码的时候他们是被包含在一个字符串中，只是在 eval()执行的时候才会创建。\n\nwindow 对象\n\n​ js 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理。因此，所有全局作用域声明的变量和函数都变成了 window 对象的属性。下面展示另一种获取 Global 对象的方式\n\n```javaScript\nlet global=function(){\nreturn this;\n}\n```\n","tags":["JavaScript"]},{"title":"Es6-Class","url":"/blog/2023/02/27/Es6-Class/","content":"\n## class\n\n#### 1.基本含义，以及使用注意\n\n##### class 声明类的简单示例\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\nconst p = new Point(1, 2);\n```\n\n##### class 声明类的注意点\n\n1. 类中 this 关键字代表的是实例对象 即 this===p\n\n2. 在 class 里面声明方法不需要在前面加上 function，并且方法与方法之前不需要加逗号分隔，加了会报错\n\n3. class 声明的类 类型是 function，并且类本身就是指向 constructor\n\n4. 类本身是指向构造函数的，所以构造函数的 prototype 属性还是继续存在，并且实际上所有在类里面定义的方法都是定义在 prototype 上的，因此 在实例上调用方法，实际上是在调用原型上的方法\n\n5.类中定义的所有方法都是不可枚举的\n\n#### 2.constructor()方法\n\n1.一个类一定会有一个 constructor 方法，如果没有的话，会自动默认添加一个空的 constructor 方法\n\n2.constructor 会默认返回实例对象 即 this，也可以手动设置返回一个全新的对象\n\n3.类必须使用 new 关键字来调用，因为类的实际类型也是 Function，但与普通函数的区别就是 普通函数不需要 new 关键字来调用\n\n#### 3.类的实例\n\n```javascript\nclass Point {\n  //...\n}\n// 类的实例使用new关键字进行生成\nconst point = new Point();\n// 直接调用 Point() 会报错\n```\n\n1.类的属性和方法 除非显式定义在其本身(即在 this 对象上，类的实例上)，否则都是定义在其原型上(即定义在 class 上)\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x; //显式定义\n    this.y = y;\n  }\n  // 下面方法为定义到原型上\n  toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\n\nconst p1 = new Point(1, 2);\nconst p2 = new Point(3, 4);\n// 类的所有实例都是共享一个原型对象的\np1._proto_ === p2._proto_; //true\n// 上述代码因为p1和p2都是类Point的实例 所以他们的原型都是Point.prototype 所以_proto_属性是相等的\n```\n\n2.实例属性的新写法\n\n新写法就是可以将原本写在 constructor()方法中 this 上面的属性，写到类的最顶层\n\n```javascript\nclass Point {\n  _count = 0; // 新写法，不需要加this，依然是定义到类的实例上\n}\n```\n\n3.取值函数(getter)和存值函数(setter)\n\n在类的内部 对某个属性使用 get 和 set 关键字，可以对该属性进行取值和存值行为的拦截\n\n```javascript\nclass Point {\n  constructor() {}\n  get prop() {\n    // 对prop属性进行 取值操作拦截\n    return \"getter\";\n  }\n  set prop(value) {\n    // 对prop属性进行 存值操作拦截\n    return \"setter\" + value;\n  }\n}\nconst p1 = new Point();\nconsole.log((p1.prop = \"123\")); // 'setter123'\nconsole.log(p1.prop); // 'getter'\n```\n\n4.属性表达式\n\n类中定义属性的，可以采用表达式的形式\n\n#### 4.静态方法\n","tags":["Es6-Class"]}]