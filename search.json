[{"title":"Hello World","url":"/blog/2023/03/19/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"基本引用类型","url":"/blog/2023/03/02/基本引用类型/","content":"### 基本引用类型\n\n​\t引用值（或者对象）是某个特定引用类型的实例。\n\n​\t引用类型是把数据和功能组织到一起的结构。引用类型有时候也被称为是对象定义，因为他们描述了自己的对象应有的属性的方法。\n\n​\t新对象通过 new 操作符后跟一个构造函数来创建 例如：\n\n```javascript\n let now = new Date()\n // 上面 now这个变量保存的就是通过 new操作符 来创建的一个Date引用类型的实例\n```\n\n#### 1.Date\n\n​\t`let now = new Date()` 使用new操作符来调用Date构造函数创建一个日期对象\n\n​\t上述创建的日期对象保存的是当前的日期和时间。\n\n​\t如果需要基于其他时间进行创建 则需要将时间毫秒表示的参数传给Date构造函数，参数也可以是`Date.parse()`方法支持的日期格式，因为在Date构造函数会隐式调用`Date.parse()`,如果传入错误的参数 将会返回NaN。\n\n​\t`Date.UTC()`也是一个基于其他时间创建日期对象的一个方法。但是传入的参数很特殊，需要传入年、零起点月数（1月是0，2月是1，以此类推）、日（1~31）、时（0～23）、分、秒和毫秒。其中年、月为必填，其他参数没填 日默认为1，剩余参数默认为0。`Date.UTC()`也支持隐式调用，但是隐式调用返回的是本地日期，相反则返回的是GMT日期。该方法使用如下\n\n```javascript\n// GMT时间 2000年1月1日零点\nconst dateUtc = new Date(Date.UTC(2000,0))\n\n// GMT时间 2005年5月5日17时55分55秒\nconst dateUtc2 = new Date(Date.UTC(2005,4,5,17,55,55))\n\n// 本地时间 2000年1月1日零点\nconst dateUtc = new Date(2000,0)\n\n```\n\n​\t`Date.now()`方法返回执行时日期和时间的毫秒数 也就是时间戳\n\n​\t引用类型还重写了`toLocaleString()、toString()、valueOf()`方法\n\n#### 2.RegExp\n\n#### 3.原始值包装类型\n\n​\t原始值包装类型：js针对Number,String,Boolean 三个类型的原始值, 提供的特殊引用类型。这三种类型有引用类型的一些基本特点，也有原始类型对应的特殊行为。\n\n​\t1.在用到某个原始值的方法或者属性的时候，后台会自动创建一个相应的原始包装类型的对象，会执行如下三步操作\n\n​\t\t1）创建一个原始值包装类型的实例\n\n​\t\t2）调用实例上的特定方法\n\n​\t\t3）销毁实例\n\n​\t2.引用类型与原始值包装类型的主要区别:  对象的生命周期，自动创建的原始值包装对象只存在于访问他的那行代码，过后就会被销毁。 而通过new实例化引用类型后，其生命周期会在离开作用域时被销毁。\n\n​\t3.在原始值包装类型的实例上调用 typeof 返回 ‘object’\n\n#####   Boolean\n\n​\t1.创建一个Boolean对象示例 需要在Boolean构造函数传入 true或者false\n\n​\t  `let booleanObject = new Boolean(true)`\n\n​\t2.Boolean对象生成的实例 重写了valueOf()方法，返回原始值true或者false，toString()方法 返回'true'或'false'，生成的实例类型是obejct，所以在进行布尔表达式转换的时候 不管生成实例传入的是true或false 都会返回true，所以要减少Boolean对象的使用。\n\n#####  \tNumber\n\n​\t\t1.创建一个Number对象，就使用Number构造函数并传入一个数值\n\n​\t\t\t`const numberObject = new Number(10)`\n\n​\t\t2.Number类型重写了valueOf()，toString()，toLocalString()方法，其中除了valueOf返回原始数值外，另外两个方法皆返回数值字符串。\n\n​\t\t3.toFixed()  接受一个参数，表示结果中小数的位数，返回包含指定小数点位数的数值字符串。（toFixed()方法支持0～20个小数位的数值）\n\n​\t\t`let num=10; console.log(num.toFixed(2)); //'10.00'`\n\n​\t\ttoExponential()方法返回以科学记数法表示的数值字符串，传参与toFixed()相同\n\n​\t\t`let num = 10; console.log(num.toExponential(1)); // '1.0e+1'`\t\n\n​\t\ttoPrecision()方法 会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法，接受一个参数，表示结果中数字的总位数（不包含指数）\n\n```javaScript\nlet num = 99\nconsole.log(num.toPrecision(1));//\"1e+2\"\nconsole.log(num.toPrecision(2)); // '99'\nconsole.log(num.toPrecision(3));//'99.0'\n```\n\n​\t\t4.使用原始值包装类型创建出来的 Number 实例----类型是 'object';\n\n​\t\t5.isInteger()方法用于判别一个数值是否保存为整数。小数位的值全都是0的情况下 也是一个整数\n\n​\t\t`console.log(Number.isInteger(1.00)) //true`\n\n##### \tString\n\n​\t\t1.创建一个String对象，使用String构造函数并传入一个字符串\n\n​\t\t\t`let stringobject = new String('hello world');`\t\n\n​\t\t2.length属性：String对象的length属性 表示字符串中字符的数量，其中字符串中包含双字节字符(而不是单字节的ASCII字符)，也仍然会按照单字符来计数。\n\n​\t\t3.javaScript字符：js的字符串是由16位码元组成。所以字符串的length属性就表示字符串包含多少16位码元。\n\n​\t\t\tcharAt()方法 接受一个整数参数，查找指定索引位置的16位码元 并返回对应的字符。\n\n​\t\t\tcharCodeAt()方法 接受一个整数参数 返回指定索引位置的码元值。\n\n​\t\t\tfromCharCode()方法 用于根据给定的utf-16码元创建字符串中的字符，可以接受任意多个数值 返回将多个数值对应的字符拼接起来形成的字符串。\n\n​\t\t\t代理对：16位只能唯一表示65536个字符，超出无法使用16位码元进行表示。但是Unicode采取 每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的方法就叫做代理对。\n\n​\t\t\tcodePointAt() 用于正确解析包含单码元字符又包含代理对字符串的字符串。传入一个整数参数 代表指定查询字符串的索引位置，返回对应位置的正确的码点。但是针对代理对 需要传入代理对开头的索引位置 才能查看该代理对正确的码点。\n\n​\t\t\tfromCodePoint()方法 同formCharCode()传参和返回值一样,但可以解析代理对的码点 返回正确的字符串。\n\n​\t\t4.字符串的操作方法\n\n​\t\t\tconcat()方法 接受任意多个参数，<b>返回拼接完成的新字符串，不会修改调用他的字符串。</b>在字符串中使用“+”号拼接字符串更为常见。\n\n​\t\t\tslice()方法返回操作字符串的一个子字符串，不会修改调用他们的字符串。接受两个参数，第一个参数表示字符串开始的位置（必填参数），第二个参数<b>表示字符串结束的位置，返回的子字符串不包含结束位置的字符，第二个参数可以省略，省略第二个参数意味着提取到字符串末尾。</b>当参数为负值的时候，slice()会用字符串长度加上参数，然后进行方法调用，也可以说为第一个参数为负数的时候，是从字符串右边开始截取。\n\n​\t\t\tsubstr()方法与上方方法返回结果一致 接受参数数量一致，同样第二个参数也可以省略，<b>但第二个参数表示返回的字符串数量。</b>substr()将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0。\n\n​\t\t\tsubstring()方法与上述两个方法返回结果一致，接受参数数量一致，第二个参数功能与slice()方法一致，但当参数出现负数的时候，会将负数参数都转为0然后进行方法执行。并且<b>该方法始终以小参数作为起点，大参数作为终点的。</b>\n\n​\t\t\tindexOf()和lastIndexOf()方法。都是从字符串中搜索传入的字符，返回字符对应的位置，并且都是找到第一个符合要求的字符就返回位置。(没查询到，则返回-1)。<b>两者的区别在于，indexOf()从头到尾进行查找，而lastIndexOf()则是从尾部到头部进行查找。</b> 上面两个方法都可以接收一个可选的第二个参数，表示开始搜索的位置。<b>所以 indexOf()将会从指定位置开始向尾部进行搜索(忽略该指定位置之前的参数)，而lastIndexOf()则会从指定位置开始从尾部向头部进行搜索(忽略该指定位置之后直到末尾的参数)。</b>\n\n​\t\t\tstartsWith()：用于从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。第一个参数为字符串必填参数，<b>传入后从索引为0开始搜索，搜索字符长度为传入字符串的长度。</b>接受第二个可选的参数，表示开始搜索的位置，忽略该位置之前的字符，但搜索范围同样是传入字符串的长度。\n\n​\t\t\tincludes()：接受参数与返回值与上方方法一致。<b>不同的是includes搜索范围是整个字符串。</b>\n\n​\t\t\tendsWith()：接受参数与返回值与上方方法一致。搜索范围也与传入字符串长度有关。<b>但不同的是该方法检查开始与索引(string.length - substring.length)的匹配项。也就说检查开始与字符串长度减去传入字符串长度的索引位置。</b>也可以接收第二个可选的参数，<b>传入的第二个参数就代表字符串的总长度。所以会改变检查开始位置。</b>\n\n​\t\t\ttrim()：该方法会创建一个字符串副本，删除前，后所有空格符，再返回结果。返回的是一个字符串副本，愿字符串不受影响。trimLeft()、trimRight()分别清空字符串左右的空格。\n\n​\t\t\trepeat()：这个方法接受一个整数参数，表示要将字符串复制多少次，然后拼接返回副本后的结果。\n\n​\t\t\t`const stringValue = 'na';console.log(stringValue.repeat(16)); //nananananananananan...`\n\n​\t\t\tpadSatrt()和padEnd()方法会复制字符串，小于指定长度，分别在左右填充字符，直至满足指定长度。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格。<b>第二个参数不限于一个字符 多个字符的字符串，会将其拼接并截断以匹配指定长度。如果第一个参数指定的长度小于或等于字符串长度，则返回原始字符串。</b>\n\n​\t\t\t字符串的迭代与解构：字符串在原型上暴露了一个@@iterator方法。表示可以迭代字符串的每个字符。可以使用for...of...进行循环，也可以通过解构操作符来进行解构。\n\n`let message = 'abcde';console.log([...message])//['a','b','c','d','e']`\n\n#### 4.单例内置对象\n\n\t#####      Global\n\n​\t\t\tGlobal对象是js中最特别的对象，因为代码不会显式访问它。Global对象是一种兜底对象，所针对的是不属于任何对象的属性和方法。在全局作用域中定义的变量和函数都会变成Global对象的属性。\n\n​\t\tURL编码方法\n\n​\t\t\tencodeURI()：用于编码统一资源标识符。该方法在编码过程中不会编码属于URL组件的特殊字符，比如冒号、斜杠、问号、井号。所以该方法一般用于对整个URL进行编码。\n\n​\t\t\tencodeURIComponent()：同样用于编码统一资源标识符。该方法会编码他发现的所有非标准字符。一般用于编码URL后面拼接的字符串。\n\n​\t\t\tdecodeURI()：仅对encodeURI编码后的字符进行解码。\n\n​\t\t\tdecodeURIComponent()：仅对encodeURIComponent()编码后的字符进行解码。\t\t\t\n\n​\t\teval()：接受一个参数，是一个要执行的js字符串。\n\n```javascript\neval(\"console.log('hi')\");\n//等价于\nconsole.log('hi');\n```\n\n\t\t\t\t1. 通过eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。\n\t\t\t\t1. 通过eval()定义的任何变量和函数都不会被提升，解析代码的时候他们是被包含在一个字符串中，只是在eval()执行的时候才会创建。\n\nwindow对象\n\n​\tjs没有规定直接访问Global对象的方式，但浏览器将window对象实现为Global对象的代理。因此，所有全局作用域声明的变量和函数都变成了window对象的属性。下面展示另一种获取Global对象的方式\t\n\n```javaScript\nlet global=function(){\nreturn this;\n}\n```\n\n\n\n\n\n\n\n\n","tags":["JavaScript"]},{"title":"Es6-Class","url":"/blog/2023/02/27/Es6-Class/","content":"## class\n\n#### 1.基本含义，以及使用注意\n\n##### class声明类的简单示例\n\n```javascript\nclass Point{\n\tconstructor(x,y){\n\t\tthis.x=x;\n\t\tthis.y=y\n\t}\n\ttoString(){\n\t\treturn '('+ this.x +','+ this.y +')'\n\t}\n}\nconst p = new Point(1,2)\n```\n\n##### class声明类的注意点\n\n1.类中this关键字代表的是实例对象 即this===p\n\n2.在class里面声明方法不需要在前面加上function，并且方法与方法之前不需要加逗号分隔，加了会报错\n\n3.class声明的类 类型是function，并且类本身就是指向constructor\n\n4.类本身是指向构造函数的，所以构造函数的prototype属性还是继续存在，并且实际上所有在类里面定义的方法都是定义在prototype上的，因此 在实例上调用方法，实际上是在调用原型上的方法\n\n5.类中定义的所有方法都是不可枚举的\n\n#### 2.constructor()方法\n\n1.一个类一定会有一个constructor方法，如果没有的话，会自动默认添加一个空的constructor方法\n\n2.constructor会默认返回实例对象 即this，也可以手动设置返回一个全新的对象\n\n3.类必须使用new关键字来调用，因为类的实际类型也是Function，但与普通函数的区别就是 普通函数不需要new关键字来调用\n\n#### 3.类的实例\n\n```javascript\nclass Point\t{\n\t//...\n}\n// 类的实例使用new关键字进行生成\nconst point=new Point()\n// 直接调用 Point() 会报错\n```\n\n1.类的属性和方法 除非显式定义在其本身(即在this对象上，类的实例上)，否则都是定义在其原型上(即定义在class上)\n\n```javascript\nclass Point {\n\tconstructor(x,y){\n\t\tthis.x=x //显式定义 \n\t\tthis.y=y\n\t}\n\t// 下面方法为定义到原型上\n\ttoString(){\n\t\treturn '('+this.x+','+this.y+')'\n\t}\n}\n\nconst p1=new Point(1,2)\nconst p2=new Point(3,4)\n// 类的所有实例都是共享一个原型对象的\np1._proto_ === p2._proto_ //true\n// 上述代码因为p1和p2都是类Point的实例 所以他们的原型都是Point.prototype 所以_proto_属性是相等的\n```\n\n2.实例属性的新写法\n\n新写法就是可以将原本写在constructor()方法中this上面的属性，写到类的最顶层\n\n```javascript\nclass Point\t{\n\t_count=0; // 新写法，不需要加this，依然是定义到类的实例上\n}\n```\n\n3.取值函数(getter)和存值函数(setter)\n\n在类的内部 对某个属性使用get 和 set 关键字，可以对该属性进行取值和存值行为的拦截\n\n```javascript\nclass Point\t{\n\tconstructor(){}\n\tget prop(){\n    // 对prop属性进行 取值操作拦截\n\t\treturn 'getter'\n\t}\n\tset prop(value){\n    // 对prop属性进行 存值操作拦截\n\t\treturn 'setter'+value\n\t}\n}\nconst p1=new Point()\nconsole.log((p1.prop='123')) // 'setter123'\nconsole.log(p1.prop) // 'getter'\n```\n\n4.属性表达式\n\n类中定义属性的，可以采用表达式的形式\n\n#### 4.静态方法\n\n","tags":["Es6,Class"]},{"title":"javaScript","url":"/blog/2023/02/17/javaScript/","tags":["demo"]}]