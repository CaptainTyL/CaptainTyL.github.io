[{"title":"生成器","url":"/blog/2023/05/05/生成器/","content":"### 生成器\n\n生成器是一个拥有在函数块内暂停和恢复代码执行能力的结构。\n\n#### 生成器基础\n\n1.生成器形式是一个函数，在函数名称前面加一个星号(*)表示他是一个生成器。只要可以定义函数的地方，就可以定义生成器。\n\n``` javascript\n// 声明一个生成器函数\nfunction *generatorFn(){}\n\n// 生成器函数表达式\nlet generatorFn = function *(){}\n\n// 标识生成器函数的星号不受两侧的空格影响\n//等价的生成器函数\nfunction* generatorFn(){}\nfunction *generatorFn(){}\nfunction * generatorFn(){}\n```\n\n> 箭头函数不能用来定义生成器函数\n\n2.调用生成器函数会产生一个<b>生成器对象</b>。生成器对象一开始处于暂停执行的状态。\n\n3.生成器对象实现了`Iterator`接口，拥有`next()`方法。调用该方法会让生成器开始或者恢复执行。\n\n4.`next()`方法的返回值类似于迭代器，返回`{done:true/false,value}`，如果函数体为空，调用`next()`后函数不会暂停，会返回`done:true`,如何该函数有返回值 则value的属性值就是该返回值，如果没有返回值，value属性值为`undefined`。\n\n5.生成器函数只会在初次调用`next()`方法后开始执行。\n\n```javascript\nfunction* generatorFn(){\n  console.log('foobar')\n}\nlet generatorObject=generatorFn();// 初次调用生成器函数并不会执行，没有打印控制台日志\n\ngeneratorObject.next();//foobar\n```\n\n6.生成器对象实现了Iterable接口，他们的默认迭代器是自引用的。\n\n实现了`Iterable` 接口表示 生成器函数包含`[Symbol.iterator]()`工厂函数，可以通过调用该工厂函数产生一个新的迭代器。\n\n<b>自引用的意思就是表示 在调用生成器函数的时候不光是产生了一个生成器对象，也自动调用了`[Symbol.iterator]()`工厂函数，产生了一个实现了迭代器协议的对象。所以产生的生成器对象可以使用`next()`方法。</b>\n\n```javascript\nfunction *generatorFn(){}\n\nconst g = generatorFn();\nconsole.log(g===g[Symbol.iterator]());//true\n```\n\n#### yield中断执行\n\n1.yield关键字可以让生成器停止和开始执行。生成器在遇到yield关键字之前会正常执行，遇到这个关键字之后，执行会停止，函数作用域的状态会保留。停止的生成器函数只能通过在生成器对象上调用`next()`方法来恢复执行。\n\n2.yield关键值生成的值，会出现在`next()`方法返回的对象里。通过yield关键字退出的生成器函数会处在`done:false`状态，通过return关键字退出的生成器函数会处于`done:true`状态。\n\n3.生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用`next()`不会影响其他生成器。\n\n4.yield关键字只能在生成器函数内部使用，用在生成器嵌套的非生成器函数中也不可以。\n\n```javascript\nfunction *generatorFn(){\n  yield;\n}\nlet generatorObject=generatorFn()\nconsole.log(generatorObject.next());//{done:false,value:undefined}\nconsole.log(generatorObject.nect());//{done:true,value:undefined}\n\nfunction *generatorFn1(){\n  yield 'foo';\n  yield 'bar';\n  return 'baz';\n}\n\nlet generatorObject1=generatorFn1()\nconsole.log(generatorObject1.next());//{done:false,value:'foo'}\nconsole.log(generatorObject1.nect());//{done:false,value:'bar'}\nconsole.log(generatorObject1.nect());//{done:true,value:'baz'}\n```\n\n#### 生成器对象可作为迭代器对象\n\n因为上面说到生成器对象实现了Iterable接口，他们的默认迭代器是自引用的，所以生成器函数产生的对象也可以作为一个可迭代对象。\n\n```javascript\nfunction *nTimes(n){\n  while(n--){\n    yield;\n  }\n}\nfor (let i of nTimes(3)){\n  console.log('foo')\n}\n//foo\n//foo\n//foo\n```\n\n#### 使用yield实现输入和输出\n\nyield在上述代码示例中一直是作为函数的中间返回语句使用，yield关键字还可以作为函数的中间参数使用。<b>上一次导致函数暂停的yield关键字，可以接收到生成器对象在下一次调用`next()`方法时候写入的第一个值。生成器对象第一次调用`next()`传入的值不会被使用到，因为第一次调用是为了开始执行生成器函数。</b>\n\n```javascript\nfunction *generatorFn(initial){\n  console.log(initial);\n  console.log(yield);\n  console.log(yield);\n}\nlet generatorObject=generatorFn('foo')\ngeneratorObject.next('bar');//foo 第一次调用next()传入的值不会被使用\ngeneratorObject.next('baz');//baz\ngeneratorObject.next('qux');//qux\n// yield关键字可以同时用于输入和输出\nfunction *generatorFn1(){\n  return yield 'foo'\n}\nlet generatorObject1=generatorFn1();\nconsole.log(generatorObject1.next());//{done:false,value:'foo'}\nconsole.log(generatorObject1.next('bar'));//{done:true,value:'bar'}\n\n// yield关键字在一个生成器函数中可以使用多次\n\nfunction* nTimes(n){\n  for(let i=0;i<n;i++){\n    yield i;\n  }\n}\nfor(let x of nTimes(3)){\n  console.log(x);\n}\n//0\n//1\n//2\n```\n\n#### 产生可迭代对象\n\n在yield关键字后面可以加上一个*(星号)，来增强yield的行为，让他能够迭代一个可迭代对象，从而一次产出一个值\n\n```javascript\n// 等价的generatorFn\nfunction * generatorFn(){\n  for(const x of [1,2,3]){\n    yield x;\n  }\n}\nfunction *generatorFn(){\n  yield* [1,2,3]\n}\n// yield星号两侧的空格不影响其行为\nfunction *generatorFn(){\n  yield* [1,2];\n  yield *[3,4];\n  yield * [5,6];\n}\n```\n\n<b>yield*的值是关联迭代器返回`done:true`时的value属性。</b>对于普通迭代器来说该值是undefined，对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值\n\n```javascript\nfunction* generatorFn() {\n  console.log('iter value:', yield* [1, 2, 3]);\n}\nfor (const x of generatorFn()) {\n  console.log('value:', x);\n}\n// value: 1 \n// value: 2\n// value: 3\n// iter value: undefined\n\n// 生成器函数作为迭代器使用的时候\nfunction* innerGeneratorFn() { \n  yield 'foo';\n\treturn 'bar';\n}\nfunction* outerGeneratorFn(genObj) {\n  console.log('iter value:', yield* innerGeneratorFn());\n}\nfor (const x of outerGeneratorFn()) {\n  console.log('value:', x);\n}\n// value: foo\n// iter value: bar\n```\n\n#### 生成器作为默认迭代器\n\n生成器函数调用后产生的生成器对象实现了Iterable接口，生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器可以作为默认迭代器。\n\n```javascript\nclass Foo{\n  constructor{\n    this.values=[1,2,3]\n  }\n\t* [Symbol.iterator](){\n    yield* this.values;\n  }\n}\nconst f = new Foo();\nfor(const x of f){\n  console.log(x)\n}\n//1\n//2\n//3\n```\n\n#### 提前终止生成器\n\n1.return\n\n`return()`方法会强制生成器进入关闭状态，提供给`return()` 方法的值，就是终止迭代器对象的值。\n\n与迭代器不同，所有生成器对象都有 `return()`方法，只要通过它进入关闭状态，就无法恢复了。 后续调用 `next()`会显示 `done: true` 状态，而提供的任何返回值都不会被存储或传播.\n\n`for-of`循环等内置语言结构会忽略状态为`done:true`的`IteratorObject`内部返回的值。\n\n```javascript\nfunction *generatorFn(){\n  for(const x of [1,2,3]){\n    yield x\n  }\n}\nconst g = generatorFn();\nconsole.log(g.next());//{done:true,value:1}\nconsole.log(g.return(4));//{done:true,value:4}\nconsole.log(g.next());//{done:true,value:undefined}\n\n// 忽略done：true的返回值\nfor(const x of g){\n  if(x>1){\n    g.return(4)\n  }\n  console.log(x)\n}\n//1\n//2\n```\n\n2.throw()\n\n`throw()`方法会在生成器执行<b>暂停</b>的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭。\n\n但如果生成器<b>内部</b>处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行，错误处理会跳过对应的yield。\n\n>  如果生成器对象还没有开始执行，那么调用throw()抛出的错误不会在函数内部被 捕获，因为这相当于在函数块外部抛出了错误。\n\n```javascript\nfunction* generatorFn() {\n      for (const x of [1, 2, 3]) {\n\t\t\t\tyield x; \n      }\n    }\n    const g = generatorFn();\n    console.log(g);   // generatorFn {<suspended>}\n    try {\n      g.throw('foo');\n    } catch (e) {\n      console.log(e); // foo\n\t\t}\t\t\n    console.log(g);   // generatorFn {<closed>}\n\nfunction *generatorFn(){\n  for(const x of [1,2,3]){\n    try{\n      yield x\n    }catch(e){\n      \n    }\n  }\n}\n\nconst g=generatorFn()\nconsole.log(g.next());//{done:false,value:1}\ng.throw('foo');// 注入错误在生成器函数内部被捕捉然后被yield抛出，所以对应的yield会跳过。\nconsole.log(g.next());//{done:false,value:3}\n\n```\n\n","tags":["JavaScript"]},{"title":"迭代器","url":"/blog/2023/04/20/迭代器/","content":"\n#### 迭代与循环的区别\n\n迭代是在一个有序集合上 按顺序反复多次执行一段程序，通常会有明确的终止条件，不保证会把所有数据都取完。\n循环是迭代的基础，因为循环是在指定迭代次数内反复执行某段特定的代码，往往没有明确的终止条件，通常会遍历所有数据。\n\n```javascript\nlet collection = [\"foo\", \"bar\", \"baz\"];\nfor (let index = 0; index < collection.length; ++index) {\n  console.log(collection[index]);\n}\n// 上述使用for循环来执行针对一个数组的遍历，数组作为最常见的有序集合，使用for循环 可能通过索引的递增来实现对数组元素每一项的访问。\n// 同时 也暴露出使用循环的两个痛点：\n// 1.在进行循环之前需要知道如何使用数据结构。例如上述循环的数组，是先访问数组引用然后通过一直递增的index进行访问对应位置元素的，\n// 2.遍历顺序并不是数据结构固有的。上述的数组是一个有序集合，但js中还有一个数据结构并不是都是有序的。\n```\n\n#### 迭代器模式\n\n迭代器模式是指 在 js 中可以把某些结构称为<b>可迭代对象</b>（因为它们实现了正式的 Iterable 接口），而且可以通过迭代器 Iterator 进行消费。\n\n可迭代对象：是一种抽象的说法。通常可以把数组和集合这样的集合类型的对象称为可迭代对象。通常这样的类型<b>包含的元素都是有限的，并且都具有无歧义的遍历顺序,但是，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构。</b>\n\n迭代器：迭代器是按需创建的一次性对象，每个迭代器都是关联一个可迭代对象，而迭代器会暴露其关联的可迭代对象的 api。所以迭代器无须了解与其关联的可迭代对象本身的结构，只需要知道如何取得连续的值。\n\n#### 可迭代协议 (实现 Iterable 接口)\n\n可迭代协议要求同时具备两种能力：支持迭代的自我识别能力和能够创建实现<b>迭代器</b>（也是 Iterator 接口的对象）的能力。\n在 js 中，根据上述可知要是一个结构想具备可迭代协议，也就是说想成为一个可迭代对象的话，就必须暴露一个属性作为<b>默认迭代器</b>，而且这个属性必须要使用特殊的`Symbol.iterator`作为键，这个默认迭代器的属性必须引用一个迭代器的工厂函数，调用这个迭代器的工厂函数必须返回一个新的迭代器。\n目前 js 中内置类型 实现了 Iterable 接口的如下：\n\n- 字符串\n- 数组\n- 映射（Map）\n- 集合（Set）\n- arguments 对象\n- NodeList 等 DOM 集合类型\n\n检查是否存在默认迭代器属性可以暴露这个工厂函数\n\n```javascript\nlet num = 1;\nlet obj = {};\n// 这两种类型没有实现迭代器工厂函数\nconsole.log(num[Symbol.iterator]); // undefined\nconsole.log(obj[Symbol.iterator]); // undefined\n\nlet str = \"abc\";\nlet arr = [\"a\", \"b\", \"c\"];\n// 这些类型都实现了迭代器工厂函数\nconsole.log(str[Symbol.iterator]); // f values() { [native code] }\nconsole.log(arr[Symbol.iterator]); // f values() { [native code] }\n\n// 调用这个工厂函数会生成一个迭代器\nconsole.log(str[Symbol.iterator]()); // StringIterator {}\n// 实际在写的时候，不需要显式调用这个工厂函数来生成迭代器。\n```\n\n实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。在 js 中 可迭代对象的语言特性包括：\n\n- for...of 循环\n- 数组解构\n- 扩展操作符\n- Array.from()\n- 创建集合\n- 创建映射\n- promise.all()接收由 promise 组成的可迭代对象\n- promise.race()接收由 promise 组成的可迭代对象\n- yield<sup>\\*</sup> 操作符，在生成器中使用\n\n> 这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器\n> 如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口\n\n#### 迭代器协议\n\n迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。\n迭代器Api使用`next()`方法在可迭代对象中遍历数据，每次成功调用`next()`方法都会返回一个`IteratorResult`对象，其中包含了迭代器返回的下一个值。若不调用`next()`，则无法知道迭代器的当前位置。\n`next()`方法返回的迭代器对象IteratorResult包含两个属性 `done`和`value`,`done`是一个布尔值，表示是否还可以再次调用`next()`取得下一个值；`value`在`done为flase` 的时候 返回可迭代对象的下一个值，在done为true的时候 返回`undefined`\n\n``` javaScript\n// 可迭代对象\nlet arr = ['foo','bar']\n\n//  使用迭代器工厂函数 创建一个可迭代对象\nlet iter = arr[Symbol.iterator]()\n\n// 执行迭代\nconsole.log(iter.next());//{done:false,value:'foo'}\nconsole.log(iter.next());//{done:false,value:'bar'}\nconsole.log(iter.next());//{done:true,value:undefined}\n```\n\n上方代码展示了 创建迭代器然后是`next()`方法按顺序迭代数组，<b>上方创建的迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达`done:true`状态，后续调用`next()`就一直返回同样的值（`{done:true,value:undefined}`）</b>\n\n> 每个迭代器都表示对可迭代对象的一次性有序遍历，不同迭代器的实例相互之间没有联系，只会独立的遍历可迭代对象。\n\n``` javaScript\n// 可迭代对象\nlet arr = ['foo','bar']\n\n//  使用迭代器工厂函数 创建一个可迭代对象\nlet iter = arr[Symbol.iterator]()\nlet iter2=arr[Symbol.iterator]()\n\nconsole.log(iter.next());//{done:false,value:'foo'}\nconsole.log(iter2.next());//{done:false,value:'foo'}\nconsole.log(iter.next());//{done:false,value:'bar'}\nconsole.log(iter2.next());//{done:false,value:'bar'}\n```\n\n> 迭代器并不与可迭代对象的某个时刻的快照绑定，而仅仅是使用<b>游标</b>来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代> 器也会反映相应的变化。\n需注意：<b>迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象</b>\n\n#### 自定义迭代器\n\n自定义迭代器 首先需要实现Iterable接口成为一个可迭代对象，然后去修改编写`[Symbol.iterator]`属性引用的工厂函数，要想该属性引用的工厂函数返回的对象能够作为迭代器使用，需要让该对象去实现Iterator接口。因为任何实现Iterator接口的对象都可以作为迭代器使用\n\n```javaScript\n// 实现Iterator接口的对象都可以作为迭代器使用\n\nclass Counter{\n  constructor(limit){\n    this.count=1;\n    this.limit=limit\n  }\n  next(){\n    if(this.count<=this.limit){\n      return {done:false,value:this.count++}\n    }else{\n      return {done:true,value:undefined}\n    }\n  }\n  [Symbol.iterator](){\n    return this;\n  }\n}\n\nlet counter=new Counter(3);\n\nfor(let i of counter){\n  console.log(i)\n}\n\n// 上方代码使用class创建了一个只能被迭代一定次数的类，这个类同样实现了可迭代协议（Iterable接口）也实现迭代器协议（Iterator接口）,所以能够使用for...of循环，但是这个类因为计数器的问题，创建多个迭代器实例情况下仍会共用一个计数器，所以他所创建的迭代器实例在迭代的时候只会生效一次。\n```\n\n```javaScript\n// 使用闭包的形式 将计数器控制起来 这样就可以避免上述代码只能迭代一次的问题。\nclass Counter{\n  constructor(limit){\n    this.limit=limit;\n  }\n  [Symbol.iterator](){\n    let count = 1,limit=this.limit;\n    return{\n      next(){\n        if(count<=limit){\n          return {done:false,value:count++}\n        }else{\n          return {done:true,value:undefined}\n        }\n      }\n    }\n  }\n}\n\nlet counter=new Counter(3);\n\nfor(let i of counter){\n  console.log(i) //1,2,3\n}\nfor(let i of counter){\n  console.log(i) //1,2,3\n}\n\n```\n\n```javaScript\nlet arr = ['foo','bar','baz']\nlet iter1=arr[Symbol.iterator]()\n\nlet iter2=iter1[Symbol.iterator]()\n\nconsole.log(iter1===iter2);//true\n\n// 上述代码说明两点，1.该方式创建的迭代器内部同样都实现了Iterable接口，2.并且[Symbol.iterator]引用的工厂函数返回的都是相同的迭代器\n```\n\n#### 提前终止迭代器\n\n- for...of循环通过break、continue、return、或者throw提前退出；\n- 解构操作并未消费所有值；\n上方两种情况都会触发迭代器关闭。\n\n创建迭代器的时候有一个可选的 `return()`方法 用于指定在迭代器提前关闭时执行的逻辑。\n`return()`方法必须返回一个IteratorResult对象。简单情况下，可以只返回`{done:true}`。\n\n``` javaScript\nclass Counter{\n  constructor(limit){\n    this.limit=limit;\n  }\n  [Symbol.iterator](){\n    let count = 1,limit=this.limit;\n    return{\n      next(){\n        if(count<=limit){\n          return {done:false,value:count++}\n        }else{\n          return {done:true,value:undefined}\n        }\n      },\n      return(){\n        console.log('Exiting early')\n        return {done:true}\n      }\n    }\n  }\n}\n\nlet counter=new Counter(3);\n\nfor(let i of counter){\n  if(i>2){\n    break;\n  }\n  console.log(i) //1,2,Exiting early\n}\n```\n\n> 需要注意：\n> 1.如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。\n> 2.因为return()方法是可选的，所以并非所有迭代器都是可以关闭的，比如 <b>数组的迭代器就是不能关闭的。</b>要想知道某个迭代器是否可以关闭，可以测试这个迭代器实例的return属性是不是函数对象。\n> <b>并且只给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用return ()方法不会强制迭代器进入关闭状态。</b>\n","tags":["javaScript"]},{"title":"集合引用类型01","url":"/blog/2023/04/09/集合引用类型01/","content":"### 集合引用类型01\n\n#### Object\n\n对象创建方式：\n\n1.使用new操作符和Object构造函数进行创建。\n\n2.使用对象字面量表示法\n\n```javascript\n// Object构造函数创建对象\nconst obj = new Object()\nobj.name=\"张三\"\nobj.age='12'\n// 对象字面量表示法  左花括号表示一个表达式的开始。\nconst obj = {\n  name:'张三',\n  age:'12'\n}\n// 在使用对象字面量表示法的时候 背后并不会实际调用Object构造函数\n```\n\n上方使用对象字面量创建对象 属性与属性值使用冒号(:)分割，两个属性之前使用逗号分隔，最后一个属性的末尾逗号可以省略。\n\n对象属性名一般可以是字符串或数值，但是数值属性会自动转换为字符串。\n\n对象属性的存取方式：\n\n1.点语法\n\n2.中括号\n\n```javascript\nconst obj = {\n\tname:'张三',\n\tage:12\n}\n//1. 点语法\nconsole.log(obj.name)\n//2.中括号 在中括号内写入属性名的字符串形式\nconsole.log(obj['name'])\n```\n\n中括号对比点语法的区别在于：中括号可以通过<b>变量</b>访问属性，并且当属性名包含可能会导致语法错误的字符，或者包含关键字或者保留字的时候 也可以使用中括号语法。\n\n#### Array\n\n##### 创建数组的几种方式\n\n1.使用Array构造函数\n\n```javascript\nlet colors = new Array();\n// 1.Array构造函数支持传入参数 传入一个数值参数 则会被当作数组长度，创建指定长度数组，\n// 传入一个或多个除数值外其他类型的数据，则会创建包含该数据的数组。\n// 2.在使用Array构造函数的时候 可以省略new操作符。\n```\n\n2.使用数组字面量\n\n数组字面量是使用中括号中包含以逗号分隔的元素列表\n\n```javascript\nlet colors=['red','blue','green']\nlet name=[];//创建一个空数组\n// 在使用数组字面量的时候也同样不会调用Array构造函数\n```\n\n3.使用`Array.from()`和`Array.of()`静态方法进行创建\n\n`from()`用于将类数组结构转换为数组实例，接受三个参数。\n\n第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个`length`属性和可索引元素的结构。\n\n第二个参数是一个可选的映射函数参数。\n\n第三个参数也是一个可选的，用于指定映射函数中this的值，但是这个重写在箭头函数中不适用。\n\n```javascript\n// Array.from()的多种使用场景\n// 将字符串转换为数组\nconsole.log(Array.from('Hello'));//['H',\"e\",l\",\"l\",\"o\"]\n// 对现有数组执行浅复制\nconst a1=[1,2,3,4,5];\nconst a2=Array.from(a1)\nconsole.log(a1===a2);//false\n// 将集合和映射转换为一个新数组\nconst m = new Map().set(1,2).set(3,4);\nconst s = new Set().add(1).add(2).add(3).add(4);\nconsole.log(Array.from(m)) // [[1,2],[3,4]]\nconsole.log(Array.from(s)) // [1,2,3,4]\n// from()转换带有lenght属性的自定义对象\nconst arrayLikeObject={\n  0:1,\n  1:2,\n  2:3,\n  3:4,\n  length:4\n}\nconsole.log(Array.from(arrayLikeObject));//[1,2,3,4]\n\n// 接受第二个可选参数的时候\nconst a1=[1,2,3,4]\nconst a2=Array.from(a1,x=>x**2);\n// 接受第三个可选参数\nconst a3=Array.from(a1,function(x){return x**this.exponent},{exponent:2})\n```\n\n`Array.of()`可以把一组参数转换为数组。\n\n```javascript\nconsole.log(Array.of(1,2,3,4)) //[1,2,3,4]\n```\n\n##### 数组空位\n\n使用数组字面量初始化数组时候，可以使用一串逗号来创建空位。\n\n使用Array构造函数 传入数值创建指定长度数组的时候，也是创建包含指定长度空位的数组。\n\nECMAScript会将逗号之间相应的索引位置的值当成空位。Es6新增的方法普遍将这些空位当成存在的元素 只不过值是`undefined`。\n\n```javascript\nlet arr1=[,,,,];//字面量方法创建数组空位\nlet arr2=new Array(5)//构造函数方法创建包含指定长度空位的数组\nlet arr3=Array.from([,,,]);//也可以创建包含空位的数组\n```\n\nEs6之前的方法会忽略这个空位。但具体的行为也会因方法而异。\n\n```javascript\n// map会跳过空位\nconlose.log([1,,,,5].map(item=>6));//[6,undefined,undefined,undefined,6]\n// join()会当空位为空字符串\nconsole.log([1,,,,5].join('-'));//\"1----5\"\n```\n\n##### 数组索引\n\n1.使用中括号[]在其中写入相应值的数字索引，可以读取或者修改数组指定索引位置的值。\n\n2.当在设置指定索引位置值的时候写入的索引，超过数组数组最大索引的时候则数组长度会自动扩展到该索引值加1。\n\n3.数组的length属性，始终返回0或者大于0的值。\n\n4.length属性不是只读的，是可以修改的，通过修改length属性可以实现数组元素的删除和增加。但是增加的元素如果没进行赋值则以`undefined`填充该值，也可以说是空位。\n\n```javascript\nlet colors = ['red','blue','green'];\nconsole.log(colors[0]); // 'red', 通过数组索引进行取值\ncolors[1]='yellow';// 通过数组索引进行修改值\ncolors[3]='name';//通过数组索引进行添加元素\nconsole.log(colors.length);// 4 这时候数组长度为4\ncolors.length=3;// 通过修改数组length属性 删除掉数组最后一个元素\ncolors.length=5;// 通过修改数组length属性，在数组末尾增加两个数组空位。\nconsole.log(colors[4]);// undefined\ncolors[length]='xiaoming';// 在数组末尾添加元素\n```\n\n##### 检查数组\n\n1.`instanceof`检测。在一个全局作用域的情况下完全够用，当出现两个以上的不同的全局执行上下文，Array构造函数也会有所区别，所以不能使用该方法\n\n2.`Array.isArray()`方法检测。es6新增方法 没有上述缺点 推荐使用。\n\n```javascript\nif(value instanceof Array){\n  \n};\nif(Array.isArray(value)){\n  \n}\n```\n\n##### 迭代器方法\n\nes6新增的三个检索数组内容的方法。\n\n`keys()`返回数组索引的迭代器。\n\n`values()`返回数组元素的迭代器\n\n`entries()`返回索引/值对的迭代器\n\n```javascript\nconst a =['foo','bar','baz']\nconsole.log(a.keys());//[0,1,2]\nconsole.log(a.values());//['foo','bar','baz']\nconsole.log(a.entries());//[[0,'foo'],[1,'bar'],[2,'baz']]\n```\n\n##### 复制和填充方法\n\n`fill()`填充方法 用于像指定数组 填充指定值，接收三个参数，第一个参数为填充值必选，第二个参数为索引开始位置，第三个参数为结束位置 这两个参数都是可选，也可以接收负数，负数则会从数组末尾开始计算填充位置开始和结束，第三那个参数未填写 默认填充到数组结尾。使用该方法不会改变数组大小。\n\n`fill()` 静默忽略超出数组边界，零长度以及方向相反的索引范围。\n\n```javascript\nconst zeros=[0,0,0,0,0];\nzeros.fill(5);//用5填充整个数组\nzeros.fill(6,3);//用6填充 索引位置为3开始到数组末尾结束\nzeros.fill(7,1,3);//用7填充 索引位置大于等于1且小于3的元素\nzeros.fill(8,-4,-1);//用8填充 索引位置大于等于1且小4的元素\n\nzeros.fill(0);\nzeros.fill(1,-10,-6);// 不填充 索引过低 忽略\nzeros.fill(1,10,15);// 不填充 索引过高 忽略\nzeros.fill(2,4,2);//不填充 索引反向\nzeros.fill(4,3,10);//仅填充部分 [0,0,0,4,4]\n```\n\n`copyWithin()`复制方法。实现数组指定范围的浅复制。接收三个参数 第一个参数为插入数组的指定位置的索引值。第二个参数为复制开始位置 可选参数 不填则默认从0开始复制，第三个参数为复制结束位置 可选参数 同样不填则复制到数组末尾处。与`fill()`方法同样开始和结束位置支持负值。使用该方法不会改变数组大小。\n\n`copyWithin()`静默忽略超出数组边界，零长度及方向相反的索引范围。\n\n```javascript\nlet ints=[0,1,2,3,4,5,6,7,8,9];\nints.copyWithin(5);//从0开始复制到数组末尾 从索引值为5的位置开始插入。但是达到数组边界时候会停止。\nints.copyWidthin(0,5);//从索引5开始复制到数组末尾 插入到索引0开始的位置\nints.copyWithin(4,0,3);//复制索引0到3的元素，插入到索引4开始的位置\nints.copyWithin(-4,-7,-3);//复制3到7的元素 插入到索引6开始的位置\n```\n\n##### 转换方法\n\n`toString()` 将数组每一个元素调用一下`toString()`方法 然后使用逗号进行分割返回字符串。\n\n`valueOf()`返回数组本身。\n\n`toLocalString()`同样会调用数组每一个元素的`toLocalString()`方法 返回一个逗号分隔的字符串。\n\n`join()`接收一个字符串分割符参数，返回该分割符分割的字符串。\n\n如果数组中某一项是null或者undefined 则在上述四个方法返回结果中均以空字符表示。\n\n##### 栈方法\n\nes给数组提供的方法，使数组看起来像另外一种数据结构，数组对象可以像栈一样，也就是一种限制插入和删除项的操作。栈是一种<b>后进先出</b>的结构，就是最近添加的项先被删除，数据的插入和删除都只在栈顶发生。es给数组提供了`push()`和`pop()`方法。实现类似栈的行为。\n\n`push()`方法 用于像数组尾部添加元素，接收任意数量的参数，返回数组的最新长度。`\n\n`pop()`方法用于删除数组的最后一项，不需要传参，同时减少数组的length属性的值。返回被删除的项。\n\n```javascript\nlet colors=['red','green']\ncolors.push('blue','yellow')\ncolors.pop()\n```\n\n##### 队列方法\n\n队列是一种以<b>先进先出</b>的形式限制访问。队列需要在末尾添加数据，但是从开头获取数据。使用上方`push()`方法可以实现在末尾添加数据，所以es提供一个叫做`shift()`方法支持在开头获取数据。\n\n`shift()`方法 会删除数组第一项 并返回删除的数据。然后数组的长度减一。\n\n并且es还提供一个`unshift()`方法用于在数组头部添加数据。使用`unshift()`搭配`pop()`方法可以实现相反队列的操作。\n\n`unshift()`方法 用于向数据头部添加数据，接收任意数量的参数。返回数组的最新长度。\n\n##### 排序方法\n\n`reverse()`方法 可以将数组元素反向排列。\n\n`sort()`方法 会按照升序重新排列数组元素。即从小到大进行排序。`sort()`方法会在数组每一项上调用`String()`转型函数，然后比较字符串来决定顺序。即使数组内都是数值也会转换为字符串进行比较。但这样的转换后的比较方式得到结果会不是我们想要的正确排列顺序。\n\n​\t然后`sort()`方法还提供了一个可选参数 可以自定义一个比较函数进行传入 用于判断值的排序。比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值，如果两个参数相等，就返回0，如果第一个参数应该排在第二个参数后面，就返回正值。如果想要进行降序排序 需要将返回值进行交换即可。\n\n`reverse()`和`sort()`方法都返回调用他们的数组的引用，会改变原数组。\n\n```javascript\nlet values=[0,1,2,15,10];\nconsole.log(values.reverse());//[10,15,2,1,0]\nfunction compare(value1,value2){\n  if(value1<value2){\n    return -1\n  }else if(value1>value2){\n    return 1\n  }else{\n    return 0\n  }\n}\nconsole.log(values.sort(compare)); //[0,1,2,10,15]\n```\n\n##### 操作方法\n\n`concact()`方法 接收任意数量的参数，首先会创建一个当前数组的副本，并将这些参数拼接到这个副本数组的末尾，返回一个新数组。如果传入的参数是数组，则会将数组的每一项都拼接数组的末尾，如果参数不是数组则会直接添加到结果数组末尾。\n\n如果不想传入的数组在添加到末尾的时候被打平，可以在参数数组上指定一个特殊符号`Symbol.isConcatSpreadable`,将这个符号设置为false可以阻止`concat()`打平参数数组。相反，设置为true可以强制打平类数组对象。\n\n```javascript\nlet colors = [\"red\", \"green\", \"blue\"];\nlet newColors = [\"black\", \"brown\"];\nconsole.log(colors.concat(newColors));//[\"red\", \"green\", \"blue\",\"black\", \"brown\"]\nnewColors[Symbol.isConcatSpreadable] = false;\nconsole.log(colors.concat(newColors)); //[\"red\", \"green\", \"blue\",[\"black\", \"brown\"]]\n\nlet moreNewColors = {\n  [Symbol.isConcatSpreadable]: true,\n  length: 2,\n  0: \"pink\",\n  1: \"cyan\",\n};\n\nconsole.log(colors.concat(moreNewColors));//[\"red\", \"green\", \"blue\",\"pink\",\"cyan\"]\n```\n\n`slice()`方法用于创建一个包含原有数组中一个或多个元素的数组，接收两个参数，开始索引和结束索引。第二个参数选填，未传入情况下会默认返回开始索引到数组末尾的元素。可以传入负数，负数索引从数组末尾开始计算，如果结束索引小于开始索引 则返回空数组。此方法不会改变原数组，返回一个新数组\n\n```javascript\nlet colors = [\"red\", \"green\", \"blue\",\"black\", \"brown\"];\nconsole.log(colors.slice(1));//[\"green\", \"blue\",\"black\", \"brown\"]\nconsole.log(colors.slice(1,3));//[\"green\", \"blue\"]\nconsole.log(colors.slice(-2,-1));//[\"black\"]\n```\n\n`splice()`方法可以实现对数组的<b>删除</b>、<b>插入</b>、<b>替换</b>三种操作。每种操作对应的传参也不太相同。该方法返回一个数组包含被删除的元素，如果没有删除元素则返回空数组。该方法会改变原有数组。\n\n删除： 接收两个参数，第一个参数为要删除第一个元素的开始位置，第二个参数为要删除的数量，可以从数组中删除任意多个元素。\n\n插入： 接收三个参数分别是，开始位置，0(要删除的元素数量)和要插入的元素，可以在数组指定位置插入元素，第三个参数之后可以传入第四个，第五个乃至更多个要插入的元素。\n\n替换：替换实际上就是上面两种方法的结合，就是在指定位置插入元素的时候同时也执行删除操作。传参与插入类似，只是需要将第二个参数0，换成要删除元素的数量。\n\n```javascript\nlet colors = [\"red\", \"green\", \"blue\",\"black\", \"brown\"];\ncolors.splice(0,1);// 删除掉数组索引为0开始的一个元素\ncolors.splice(0,0,'name','xiao');// 在数组索引位置为0的地方插入2个元素\ncolors.splice(0,1,'red');//将数组索引为0的元素替换掉\n```\n\n##### 搜索和位置方法\n\n1.严格相等\n\n`indexOf()`:接收两个参数，第一个为必填参数要查找的元素，第二个为可选参数搜索的起始位置。该方法从数组开头往后进行检索，返回要查找元素的在数组中的位置，未找到则返回-1\n\n`lastIndexOf()`：与上方方法接收参数相同，返回值也相同，唯一不同的是，该方法从数组末尾开始向数组头部进行检索匹配。\n\n`includes()`:同样接收两个参数，必填的要查找的元素和搜索的起始位置，但返回的是一个布尔值，也就是表明数组中至少存在一个与目标参数匹配的项。\n\n上述三个方法在检索过程中均采用全等(===)进行匹配。\n\n```javascript\nlet numbers=[1,2,3,4,5,4,3,2,1];\nconsole.log(numbers.indexOf(4));//3\nconsole.log(numbers.lastIndexOf(4));//5\nconsole.log(numbers.includes(4));//true\n\nconsole.log(numbers.indexOf(4,4));//5\nconsole.log(numbers.lastIndexOf(4,4));//3\nconsole.log(numbers.includes(4,7));//false\n```\n\n2.断言函数\n\n断言函数接收3个参数，第一个参数为当前搜索的元素，第二个参数为当前搜索元素的索引，第三个参数为索索数组本身。断言函数返回真值，表示是否匹配。\n\n`find()`和`findIndex()`方法第一个参数就是一个断言函数。同时这两个方法也都接收第二个可选的参数，用于指定断言函数内部的this的值。在断言函数中匹配到符合条件的数组成员时候，<b>`find()`方法返回第一个匹配的元素,`findIndex()`返回第一个匹配元素的索引。</b><b>并且当找到匹配项后，这两个方法都不在继续搜索。</b>当断言函数遍历匹配所有数组成员后，未能发现符合条件的成员则`find()`返回undefined,`findIndex()`返回-1。\n\n```javascript\n[1, 4, -5, 10].find((n) => n < 0);//返回 -5\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\nfunction f(v){\n  return v > this.age;\n}\nlet person = {name: 'John', age: 20};\n[10, 12, 26, 15].find(f, person);    // 26\n\n// 使用find()和findIndex()还可以弥补 indexOf()检测不出来NaN的问题\n[NaN].indexOf(NaN)\n// -1\n[NaN].findIndex(y => Object.is(NaN, y))\n// 0\n```\n\n##### 迭代方法\n\njs提供给数组的五个迭代方法，每个方法均接收两个参数，第一个参数为以数组每一项为参数运行的函数，这个函数可以接收三个参数：数组元素，元素索引和数组本身。第二个参数是可选的座位函数运行上下文的作用域对象。（影响函数中this的值），\n\n`every()`:对数组的每一项都运行传入的函数，如果每一项函数都返回true，则这个方法返回true。\n\n`filter()`：对数组的每一项都运行传入的函数，函数返回true的项会组成数组之后返回。\n\n`forEach()`:对数组的每一项都运行传入的函数，没有返回值。\n\n`map()`：对数组的每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。\n\n`some()`:对数组的每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true。\n\n上述几个方法均不会改变调用他们的原数组。\n\n##### 归并方法\n\n`reduce()`:会迭代数组的所有项，并在此基础上构建一个最终返回值。接收2个参数，第一个参数是一个对每一项都会运行的归并函数，该函数接收4个参数：<b>上一个归并值、当前项、当前项的索引和数组本身。并且这个函数的返回的任何值都会作为下一次调用同一个函数的第一个参数。</b>第二个参数是可选的归并起点的初始值。<b>如果没传第二个参数，则第一次迭代默认把数组的第一项当作起始值，所以第一次迭代就会从数组的第二项开始。所以传给归并函数的第一个参数是第一项，第二个参数是数组的第二项</b>\n\n`reduceRight()`:与上方方法行为基本相同，唯一不同的就是 会从数组的最后一项开始遍历至第一项。\n\n```javascript\nlet values=[1,2,3,4,5];\nlet sum=values.reduce((prev,cur,index,array)=>prev+cur);//15\n```\n\n#### 定型数组\n\n","tags":["JavaScript"]},{"title":"【typescript】01常见类型","url":"/blog/2023/03/28/【typescript】01常见类型/","content":"\n> typescript 中“类型”指的是在声明变量和函数的时候 对变量指定 ts 类型，对函数的入参和返回值指定 ts 类型。<br>\n> 在 ts 中指定变量，函数的类型，后续的赋值或者函数的返回值，都需要是符合指定类型的值才可以通过 ts 的校验。<br>\n> 这一次主要是学习最基本和常见的类型，这些是构建更复杂类型的基础\n\n### 原始类型\n\n`string`,`number`,`boolean`\njs 中最常用到的三种原始数据类型，在 ts 中都有对应的类型。用法如下：\n\n```javascript\nlet str: string = \"\";\nlet strNum: number = 0;\nlet strBol: boolean = false;\n```\n\n### 数组类型\n\n```javascript\nlet arr: number[] = [1, 2]; // 表示指定一个number类型的数组\nlet arrNew: Array<number> = [1, 2, 3]; // 第二种写法 同样指定一个number类型的数组\n```\n\n### any\n\nany 是 ts 中一个特殊的类型，当你不希望一个值导致类型检查错误的时候，就可以设置为 any。\n\n### noImplicitAny\n\n如果你没有指定一个类型，TypeScript 也不能从上下文推断出它的类型，编译器就会默认设置为 any 类型。\n\n如果你总是想避免这种情况，毕竟 TypeScript 对 any 不做类型检查，你可以开启编译项 noImplicitAny，当被隐式推断为 any 时，TypeScript 就会报错。\n\n### 变量上的类型注解\n\n上面针对 ts 类型的使用示例中，在变量后面加上例`:number`，叫做类型注解。也是在进行显式指定变量类型。\n\n> 不过大部分时候，使用类型注解显式指定变量类型不是必须的。因为 ts 会自动推断类型。举个例子，变量的类型可以基于初始值进行推断\n\n### 函数\n\n在使用 ts 声明一个函数的时候，可以对函数的入参参数类型 和函数的返回值类型 进行类型注解的添加。\n\n#### 参数类型注解\n\n当你声明一个函数的时候，你可以在每个参数后面添加一个类型注解，声明函数可以接受什么类型的参数。参数类型注解跟在参数名字后面：\n\n```javascript\nfunction func1(name: string) {}\n```\n\n#### 返回值类型注解\n\n```javascript\nfunction getFavoriteNumber(): number {\n  return 26;\n}\n```\n\n### 匿名函数\n\n匿名函数往往针对参数不需要添加类型注解，因为 ts 会根据上下文推断出参数的类型。\n\n### 对象类型\n\n定义一个对象类型，需要列出他的属性和属性对应的类型即可\n\n```javascript\nfunction printCoord(pt: { x: number, y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n\n// 上方函数 针对参数pt添加一个ts对象类型，类型有两个属性，分别指定了number类型，属性之前可以使用`,`或者`;`分割。最后一个属性可加可不加。\n// 每个属性对应的类型是可选的，如果你不指定，默认使用 any 类型。\n```\n\n可选属性：在对象类型中，可以指定属性是可选的，需要在属性名后面加一个`?`\n\n```javascript\nfunction printName(obj: { first: string, last?: string }) {\n  // ...\n}\n```\n\n### 联合类型\n\n一个联合类型是由两个或者更多类型组成的类型，表示值可能是这些类型中的任意一个。这其中每个类型都是联合类型的成员（members）。\n如下：\n\n```typescript\nfunction printName(name: number | string) {}\n```\n\n上方`number | string`这种写法就是定义了一个联合类型，表明这个函数入参类型可以是`number`或者`string`\n\n> 但是在使用联合类型的时候，不能使用一种类型独有的方法。\n> 想要使用一种类型独有的方法时：可以采用类型判断的写法进行使用。例如：\n\n```typescript\nfunction printName(name: string[] | string) {\n  if (Array.isArray(name)) {\n    // 可以使用数组特有的方法\n  } else {\n    // 可以使用 string类型特有的方法\n  }\n}\n```\n\n> 当联合类型成员 都有的一个共同方法在被调用的时候，则不需要做上述操作\n\n### 类型别名\n\n使用 type 关键字创建类型别名。更多的是用来代替重复使用的对象类型和联合类型。语法使用如下：\n\n```typescript\ntype Point = {\n  x: number;\n  y: number;\n};\n\nfunction printCrof(pt: Point) {}\n\ntype Id = number | string;\n```\n\n> 注意别名是唯一的别名，你不能使用类型别名创建同一个类型的不同版本。当你使用类型别名的时候，它就跟你编写的类型是一样的\n\n### 接口\n\n使用 interface 命名对象类型\n\n```typescript\ninterface Point {\n  x: number;\n  y?: number;\n}\n\nfunction printCrof(pt: Point) {}\n```\n\n### 类型断言\n\n类型断言 常常用在你明确知道一个值的类型的时候，但是 ts 不知道的时候，使用 as 关键字为该值指定类型，也可以使用尖括号`<T>`(在.tsx 中不能使用)的形式\n\n```typescript\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n// 或者\nconst myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");\n```\n\n> 因为类型断言会在编译的时候被移除，所以运行时并不会有类型断言的检查，即使类型断言是错误的，也不会有异常或者 null 产生。\nTypeScript 仅仅允许类型断言转换为一个更加具体或者更不具体的类型。\n双重断言：先断言为 any （或者是 unknown），然后再断言为期望的类型：\n\n```typescript\nconst a=(expr as any) as T\n```\n\n### 字面量类型\n\n字面量类型指的是：将类型声明为更具体的数值或字符串。\n\n```typescript\nlet x:'hello'='hello';\n// 上方代码中类型注解使用'hello'字符串代替。表示x这个变量只能被赋予hello这个字符串才可以\n\n// 字面量类型更多的是配合联合类型进行使用\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\n// 上方函数第二个参数仅可以传入指定字面量联合类型 三个值中的一个\n```\n\n还有一种布尔字面量类型 因为只有两种布尔字面量类型， true 和 false ，类型 boolean 实际上就是联合类型 true | false 的别名。\n\n#### 字面量推断\n\n字面量推断就是：在声明一个对象的时候，对象内属性使用字面量类型进行注解，但ts会默认你会修改对象里面属性的值，所以就会自动推断对象属性值对应的类型是普通的number或者string类型。\n在使用到对象属性值的时候 因为ts推断的类型导致与定义的字面量类型对应不上的。可以使用下面两个解决办法：\n1.针对使用到的对象属性值使用类型断言 指定属性值的正确类型\n2.对整个对象使用`as const` 把整个对象转为一个类型字面量.as const 效果跟 const 类似，但是对类型系统而言，它可以确保所有的属性都被赋予一个字面量类型，而不是一个更通用的类型比如 string 或者 number 。\n","tags":["typescript"]},{"title":"开发问题记录","url":"/blog/2023/03/23/开发问题记录/","content":"\n### html2Canvas 生成海报---图片跨域\n\n#### 问题描述和要点\n\n- 使用 html2Canvas 生成海报的时候，出现图片提示跨域无法展示的问题，经过第一次百度过后，发现需要设置 img 标签 crossOrigin 属性`crossOrigin=\"anonymous\" `，接着设置 html2canvas 的参数`useCORS: true`。\n- 本以为很简单就可以解决的时候，发布到线上环境，才发现这个坑远不止这么简单，单单设置这两个属性和参数还无法解决图片跨域问题，在经过又一番百度，发现一种解释刚好符合我现在遇到问题的情况。\n\n1. 原来是因为在 html 中 img 标签能正常进行图片访问，并且通过 <img> 加载的图片，浏览器默认情况下会将其缓存起来。\n2. 但 html2Canvas 在生成海报接受 dom 传入的时候，代码中创建的 <img> 再去访问同一个图片时，浏览器就不会再发起新的请求，而是直接访问缓存的图片。但是由于 JS 中的 <img> 同样也是设置了 crossorigin，也就意味着它将要以 CORS 的方式请求，但缓存中的图片显然不是的，所以浏览器直接就拒绝了。当我们在浏览器 network 面板勾选 disable cache 选项，就会不从缓存中进行图片访问 就可以正常展示图片了。\n\n#### 问题解决\n\n- 因为 js 创建的 img 标签是以访问缓存的方式去展示图片的，所以在 html2Canvas 渲染的时候，我就想不让其通过缓存去访问，那么每一次访问图片路径地址都需要是一个不相同的地址。所以我就采用了很暴力的办法，就是在图片路径后面直接进行时间戳参数的拼接`?t=${new Date().getTime()}`,这样就保证了每一次图片访问都会进行跨域请求。\n\n### js 小数点计算 精度丢失问题\n\n0.1 + 0.2 === 0.30000000000000004 的问题\n\n#### 解决办法\n\n1.将数字转换为整数\n\n```javaScript\nfunction add(num1, num2) {\n const num1Digits = (num1.toString().split('.')[1] || '').length;\n const num2Digits = (num2.toString().split('.')[1] || '').length;\n const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n return (num1 * baseNum + num2 * baseNum) / baseNum;\n}\n```\n\n或者\n\n```javaScript\nconsole.log(+(0.1 + 0.2).toFixed(1)) // 0.3\n```\n\n2.使用 lodash.js\n","tags":["问题记录"]},{"title":"vue-quill-editor基本使用","url":"/blog/2023/03/22/vue-quill-editor基本使用/","content":"\n##### Quill.js 富文本（vue-quill-editor）\n\n最近在做一个富文本编辑器，在网上对比找了一圈，选择了[Quill.js](https://www.kancloud.cn/liuwave/quill/1409423)，这是一款偏向底层，易于扩展的富文本编辑器，但是对于新手不太友好，目前来说这个库我自己也没有进行深入的使用和研究，因为目前项目主要以 vue 的为主，所以这次选择了对这个库进行过二次封装的[vue-quill-editor](https://github.com/surmon-china/vue-quill-editor)组件。不过在这次的使用也遇到一些问题。在这里记录一下\n\n###### 1.安装 vue-quill-editor\n\n```javascript\nnpm install vue-quill-editor --save\n```\n\n###### 2.针对 vue-quill-editor 在进行组件的二次封装\n\nvue-quill-editor 封装中的说明：\n\n1.在样式中对原有样式中有英文描述的使用中文进行覆盖\n\n2.引入组件的同时 需要将 quill 的样式文件也进行引入\n\n```javascript\n<template>\n  <div>\n    <quill-editor\n      class=\"editor\"\n      :content=\"content\"\n      :options=\"editorOption\"\n      ref=\"myQuillEditor\"\n      @change=\"onEditorChange($event)\"\n    >\n    </quill-editor>\n  </div>\n</template>\n<script>\nimport \"quill/dist/quill.core.css\";\nimport \"quill/dist/quill.snow.css\";\nimport \"quill/dist/quill.bubble.css\";\nimport { quillEditor } from \"vue-quill-editor\";\n\nconst toolbarOptions = [\n  [\"bold\", \"italic\", \"underline\", \"strike\"], // 加粗 斜体 下划线 删除线\n  [\"blockquote\", \"code-block\"], // 引用  代码块\n  [{ header: 1 }, { header: 2 }], // 1、2 级标题\n  [{ list: \"ordered\" }, { list: \"bullet\" }], // 有序、无序列表\n  [{ script: \"sub\" }, { script: \"super\" }], // 上标/下标\n  [{ indent: \"-1\" }, { indent: \"+1\" }], // 缩进\n  // [{'direction': 'rtl'}],                         // 文本方向\n  [{ size: [\"small\", false, \"large\", \"huge\"] }], // 字体大小\n  [{ header: [1, 2, 3, 4, 5, 6, false] }], // 标题\n  [{ color: [] }, { background: [] }], // 字体颜色、字体背景颜色\n  [{ font: [] }], // 字体种类\n  [{ align: [] }], // 对齐方式\n  [\"clean\"], // 清除文本格式\n  [\"link\", \"image\", \"video\"], // 链接、图片、视频\n]; //工具菜单栏配置\n\nexport default {\n  props:{\n    content: {\n      type: String,\n      default: ''\n     }\n   },\n  components: {\n    quillEditor,\n  },\n  data() {\n    return {\n      editorOption: {\n        modules: {\n          toolbar: {\n            container: toolbarOptions,\n            handlers: {},\n          },\n        },\n        placeholder: \"请输入内容......\",\n        readOnly: false,\n        theme: \"snow\", //主题 snow/bubble\n      },\n    };\n  },\n  methods: {\n    // 富文本组件change事件\n    onEditorChange({ quill, html, text }) {\n      this.$emit(\"editorChange\", html);\n    },\n  },\n};\n</script>\n<style lang=\"scss\">\n.editor {\n  line-height: normal !important;\n  height: 590px;\n  .ql-container {\n    height: 500px !important;\n    border: 1px solid #ebebeb !important;\n    border-bottom-left-radius: 4px;\n    border-bottom-right-radius: 4px;\n    border-top: 0 !important;\n  }\n  .ql-toolbar {\n    border: 1px solid #ebebeb !important;\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n  }\n  .ql-snow .ql-tooltip[data-mode=\"video\"] {\n    left: 112px !important;\n  }\n  .ql-snow .ql-tooltip[data-mode=\"video\"]::before {\n    content: \"请输入视频地址:\";\n  }\n  .ql-tooltip[data-mode=\"link\"]::before {\n    content: \"请输入链接地址:\";\n  }\n  .ql-snow .ql-tooltip[data-mode=\"link\"] {\n    left: 112px !important;\n  }\n  .ql-formats {\n    > .ql-picker.ql-size {\n      .ql-picker-label::before {\n        content: \"14px\";\n      }\n      .ql-picker-item::before {\n        content: \"14px\";\n      }\n      .ql-picker-label[data-value=\"small\"]::before {\n        content: \"10px\";\n      }\n      .ql-picker-item[data-value=\"small\"]::before {\n        content: \"10px\";\n      }\n      .ql-picker-label[data-value=\"large\"]::before {\n        content: \"18px\";\n      }\n      .ql-picker-item[data-value=\"large\"]::before {\n        content: \"18px\";\n      }\n      .ql-picker-label[data-value=\"huge\"]::before {\n        content: \"32px\";\n      }\n      .ql-picker-item[data-value=\"huge\"]::before {\n        content: \"32px\";\n      }\n    }\n    > .ql-picker.ql-header {\n      .ql-picker-label::before {\n        content: \"文本\";\n      }\n      .ql-picker-item::before {\n        content: \"文本\";\n      }\n      .ql-picker-label[data-value=\"1\"]::before {\n        content: \"标题1\";\n      }\n      .ql-picker-item[data-value=\"1\"]::before {\n        content: \"标题1\";\n      }\n      .ql-picker-label[data-value=\"2\"]::before {\n        content: \"标题2\";\n      }\n      .ql-picker-item[data-value=\"2\"]::before {\n        content: \"标题2\";\n      }\n\n      .ql-picker-label[data-value=\"3\"]::before {\n        content: \"标题3\";\n      }\n      .ql-picker-item[data-value=\"3\"]::before {\n        content: \"标题3\";\n      }\n\n      .ql-picker-label[data-value=\"4\"]::before {\n        content: \"标题4\";\n      }\n      .ql-picker-item[data-value=\"4\"]::before {\n        content: \"标题4\";\n      }\n      .ql-picker-label[data-value=\"5\"]::before {\n        content: \"标题5\";\n      }\n      .ql-picker-item[data-value=\"5\"]::before {\n        content: \"标题5\";\n      }\n      .ql-picker-label[data-value=\"6\"]::before {\n        content: \"标题6\";\n      }\n      .ql-picker-item[data-value=\"6\"]::before {\n        content: \"标题6\";\n      }\n    }\n    > .ql-picker.ql-font {\n      .ql-picker-label::before {\n        content: \"标准字体\";\n      }\n      .ql-picker-item::before {\n        content: \"标准字体\";\n      }\n      .ql-picker-label[data-value=\"serif\"]::before {\n        content: \"衬线字体\";\n      }\n      .ql-picker-item[data-value=\"serif\"]::before {\n        content: \"衬线字体\";\n      }\n      .ql-picker-label[data-value=\"monospace\"]::before {\n        content: \"等宽字体\";\n      }\n      .ql-picker-item[data-value=\"monospace\"]::before {\n        content: \"等宽字体\";\n      }\n    }\n  }\n}\n</style>\n```\n\n###### 3.图片上传方法的重写\n\n原因：编辑器本身是可以进行图片上传的 不过上传的图片都是转换成 base64 放上去的。这样会导致整个编辑器输出的 html 文本过大， 提交后台接口失败。\n\n解决方法：让用户在使用上传图片的时候 直接将图片上传到服务器 然后使用返回的 url 链接放入富文本的内容中 ，因为我当前 vue 项目是使用 element 组件库 所以下面选择使用 element 中的 upload 组件 进行辅助上传\n\n- 组件内使用 element upload 组件\n\n  ```javascript\n  <template>\n    <div>\n      <!-- 使用element图片上传组件 将其隐藏主要用于辅助富文本组件上传图片 -->\n      <el-upload\n        class=\"editor-uploader\"\n        :action=\"uploadPath\"\n        :multiple=\"false\"\n        :show-file-list=\"false\"\n        :on-success=\"uploadSuccess\"\n        :before-upload=\"beforeUpload\"\n        v-show=\"false\"\n      >\n      </el-upload>\n      <quill-editor\n        class=\"editor\"\n        :content=\"content\"\n        :options=\"editorOption\"\n        ref=\"myQuillEditor\"\n        @change=\"onEditorChange($event)\"\n      >\n      </quill-editor>\n    </div>\n  </template>\n  ```\n\n- 使用 handlers 重写图片上传方法，定义编辑器中图片上传按钮事件\n\n  ```javascript\n   handlers: {\n      image: (value) => {\n         if (value) {\n            // 调用 element 上传组件\n            document.querySelector(\".editor-uploader input\").click();\n           } else {\n            this.quill.format(\"image\", false);\n             }\n       },\n    },\n  ```\n\n- 图片上传组件的拦截方法实现和成功后的写入操作\n\n  ```javascript\n     //图片上传之前限制\n      beforeUpload(file) {\n        const isImage = file.type.indexOf(\"image/\") > -1;\n        const isLt1M = file.size / 1024 / 1024 < 1;\n        if (!isImage) {\n          this.$message.error(\"仅支持上传图片!\");\n        } else if (!isLt1M) {\n          this.$message.error(\"请将图片大小控制在1MB内!\");\n        }\n        return isImage && isLt1M;\n      },\n      //图片上传成功\n      uploadSuccess(res, file, fileList) {\n        // 获取富文本示例\n        let quill = this.$refs.myQuillEditor.quill;\n        if (res.flag) {\n          // 获取光标所在的位置\n          let length = quill.getSelection().index;\n          // 插入图片\n          quill.insertEmbed(length, \"image\", res.data.url);\n          // 调整光标在图片之后\n          quill.setSelection(length + 1);\n        } else {\n          this.$message.error(\"图片上传失败！\");\n        }\n      },\n  ```\n\n###### 4.图片缩放处理\n\n- 安装富文本编辑器内图片缩放模块\n\n```javascript\nnpm install quill-image-resize-module --save\n```\n\n- 引入图片缩放模块\n\n```javascript\nimport { quillEditor, Quill } from \"vue-quill-editor\";\n\n// 引入图片缩放模块 并注册到Quill上\nimport ImageResize from \"quill-image-resize-module\";\nQuill.register(\"modules/imageResize\", ImageResize);\n```\n\n- 在 vue-quill-editor 配置中模块下 加入缩放模块\n\n```javascript\n  editorOption: {\n        modules: {\n          // 图片缩小放大插件配置\n          imageResize: {\n            displaySize: true,\n          },\n         // ...省略其他配置\n      },\n```\n\n使用图片缩放模块的注意点，在使用过程中遇到了一个报错，发现是还需要在 webpack 中加入配置 该模块才可以引入成功 继而正常使用\n\n报错问题 **<mark>Cannot read property 'imports' of undefined\"</mark>**\n\n1. 使用 webpack 打包的项目\n\n在 build 文件夹下找到 webpack.base.conf.js 文件 在 plugins 中加入如下代码\n\n```javascript\n//若文件中未引入 webpack 则需\nconst webpack = require(\"webpack\");\n\n// 在webpack插件中引入Quill.js文件\nplugins: [\n  new webpack.ProvidePlugin({\n    \"window.Quill\": \"quill/dist/quill.js\",\n    Quill: \"quill/dist/quill.js\",\n  }),\n];\n```\n\n2.使用 vue-cli 脚手架搭建的项目\n\n在 vue.config.js 中进行设置\n\n```javascript\n//若文件中未引入 webpack 则需\nconst webpack = require(\"webpack\");\n\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.plugin(\"provide\").use(webpack.ProvidePlugin, [\n      {\n        \"window.Quill\": \"quill/dist/quill.js\",\n        Quill: \"quill/dist/quill.js\",\n      },\n    ]);\n  },\n};\n```\n","tags":["vue工具"]},{"title":"Linux命令记录","url":"/blog/2023/03/21/Linux命令记录/","content":"\n> 在使用 mac 进行前端开发过程中，由于没有接触过 linux 操作系统，对 mac 的操作命令很是生疏。\n> 在使用过程遇到的 linux 命令在此进行记录总结\n\n- 查看配置网络设备\n  `ifconfig`\n- 查看端口占用情况\n  `sudo losf -i tcp:端口号`\n- 杀死指定端口\n  `kill -9 pid` (pid-为查询出端口号展示出来的 pid)\n","tags":["Linux"]},{"title":"基本引用类型","url":"/blog/2023/03/02/基本引用类型/","content":"\n### 基本引用类型\n\n​ 引用值（或者对象）是某个特定引用类型的实例。\n\n​ 引用类型是把数据和功能组织到一起的结构。引用类型有时候也被称为是对象定义，因为他们描述了自己的对象应有的属性的方法。\n\n​ 新对象通过 new 操作符后跟一个构造函数来创建 例如：\n\n```javascript\nlet now = new Date();\n// 上面 now这个变量保存的就是通过 new操作符 来创建的一个Date引用类型的实例\n```\n\n#### 1.Date\n\n​ `let now = new Date()` 使用 new 操作符来调用 Date 构造函数创建一个日期对象\n\n​ 上述创建的日期对象保存的是当前的日期和时间。\n\n​ 如果需要基于其他时间进行创建 则需要将时间毫秒表示的参数传给 Date 构造函数，参数也可以是`Date.parse()`方法支持的日期格式，因为在 Date 构造函数会隐式调用`Date.parse()`,如果传入错误的参数 将会返回 NaN。\n\n​ `Date.UTC()`也是一个基于其他时间创建日期对象的一个方法。但是传入的参数很特殊，需要传入年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0 ～ 23）、分、秒和毫秒。其中年、月为必填，其他参数没填 日默认为 1，剩余参数默认为 0。`Date.UTC()`也支持隐式调用，但是隐式调用返回的是本地日期，相反则返回的是 GMT 日期。该方法使用如下\n\n```javascript\n// GMT时间 2000年1月1日零点\nconst dateUtc = new Date(Date.UTC(2000, 0));\n\n// GMT时间 2005年5月5日17时55分55秒\nconst dateUtc2 = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));\n\n// 本地时间 2000年1月1日零点\nconst dateUtc = new Date(2000, 0);\n```\n\n​ `Date.now()`方法返回执行时日期和时间的毫秒数 也就是时间戳\n\n​ 引用类型还重写了`toLocaleString()、toString()、valueOf()`方法\n\n#### 2.RegExp\n\n#### 3.原始值包装类型\n\n​ 原始值包装类型：js 针对 Number,String,Boolean 三个类型的原始值, 提供的特殊引用类型。这三种类型有引用类型的一些基本特点，也有原始类型对应的特殊行为。\n\n​ 1.在用到某个原始值的方法或者属性的时候，后台会自动创建一个相应的原始包装类型的对象，会执行如下三步操作\n\n​ 1）创建一个原始值包装类型的实例\n\n​ 2）调用实例上的特定方法\n\n​ 3）销毁实例\n\n​ 2.引用类型与原始值包装类型的主要区别: 对象的生命周期，自动创建的原始值包装对象只存在于访问他的那行代码，过后就会被销毁。 而通过 new 实例化引用类型后，其生命周期会在离开作用域时被销毁。\n\n​ 3.在原始值包装类型的实例上调用 typeof 返回 ‘object’\n\n##### Boolean\n\n​ 1.创建一个 Boolean 对象示例 需要在 Boolean 构造函数传入 true 或者 false\n\n​ `let booleanObject = new Boolean(true)`\n\n​ 2.Boolean 对象生成的实例 重写了 valueOf()方法，返回原始值 true 或者 false，toString()方法 返回'true'或'false'，生成的实例类型是 obejct，所以在进行布尔表达式转换的时候 不管生成实例传入的是 true 或 false 都会返回 true，所以要减少 Boolean 对象的使用。\n\n##### Number\n\n​ 1.创建一个 Number 对象，就使用 Number 构造函数并传入一个数值\n\n​ `const numberObject = new Number(10)`\n\n​ 2.Number 类型重写了 valueOf()，toString()，toLocalString()方法，其中除了 valueOf 返回原始数值外，另外两个方法皆返回数值字符串。\n\n​ 3.toFixed() 接受一个参数，表示结果中小数的位数，返回包含指定小数点位数的数值字符串。（toFixed()方法支持 0 ～ 20 个小数位的数值）\n\n​ `let num=10; console.log(num.toFixed(2)); //'10.00'`\n\n​ toExponential()方法返回以科学记数法表示的数值字符串，传参与 toFixed()相同\n\n​ `let num = 10; console.log(num.toExponential(1)); // '1.0e+1'`\n\n​ toPrecision()方法 会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法，接受一个参数，表示结果中数字的总位数（不包含指数）\n\n```javaScript\nlet num = 99\nconsole.log(num.toPrecision(1));//\"1e+2\"\nconsole.log(num.toPrecision(2)); // '99'\nconsole.log(num.toPrecision(3));//'99.0'\n```\n\n​ 4.使用原始值包装类型创建出来的 Number 实例----类型是 'object';\n\n​ 5.isInteger()方法用于判别一个数值是否保存为整数。小数位的值全都是 0 的情况下 也是一个整数\n\n​ `console.log(Number.isInteger(1.00)) //true`\n\n##### String\n\n​ 1.创建一个 String 对象，使用 String 构造函数并传入一个字符串\n\n​ `let stringobject = new String('hello world');`\n\n​ 2.length 属性：String 对象的 length 属性 表示字符串中字符的数量，其中字符串中包含双字节字符(而不是单字节的 ASCII 字符)，也仍然会按照单字符来计数。\n\n​ 3.javaScript 字符：js 的字符串是由 16 位码元组成。所以字符串的 length 属性就表示字符串包含多少 16 位码元。\n\n​ charAt()方法 接受一个整数参数，查找指定索引位置的 16 位码元 并返回对应的字符。\n\n​ charCodeAt()方法 接受一个整数参数 返回指定索引位置的码元值。\n\n​ fromCharCode()方法 用于根据给定的 utf-16 码元创建字符串中的字符，可以接受任意多个数值 返回将多个数值对应的字符拼接起来形成的字符串。\n\n​ 代理对：16 位只能唯一表示 65536 个字符，超出无法使用 16 位码元进行表示。但是 Unicode 采取 每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的方法就叫做代理对。\n\n​ codePointAt() 用于正确解析包含单码元字符又包含代理对字符串的字符串。传入一个整数参数 代表指定查询字符串的索引位置，返回对应位置的正确的码点。但是针对代理对 需要传入代理对开头的索引位置 才能查看该代理对正确的码点。\n\n​ fromCodePoint()方法 同 formCharCode()传参和返回值一样,但可以解析代理对的码点 返回正确的字符串。\n\n​ 4.字符串的操作方法\n\n​ concat()方法 接受任意多个参数，<b>返回拼接完成的新字符串，不会修改调用他的字符串。</b>在字符串中使用“+”号拼接字符串更为常见。\n\n​ slice()方法返回操作字符串的一个子字符串，不会修改调用他们的字符串。接受两个参数，第一个参数表示字符串开始的位置（必填参数），第二个参数<b>表示字符串结束的位置，返回的子字符串不包含结束位置的字符，第二个参数可以省略，省略第二个参数意味着提取到字符串末尾。</b>当参数为负值的时候，slice()会用字符串长度加上参数，然后进行方法调用，也可以说为第一个参数为负数的时候，是从字符串右边开始截取。\n\n​ substr()方法与上方方法返回结果一致 接受参数数量一致，同样第二个参数也可以省略，<b>但第二个参数表示返回的字符串数量。</b>substr()将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。\n\n​ substring()方法与上述两个方法返回结果一致，接受参数数量一致，第二个参数功能与 slice()方法一致，但当参数出现负数的时候，会将负数参数都转为 0 然后进行方法执行。并且<b>该方法始终以小参数作为起点，大参数作为终点的。</b>\n\n​ indexOf()和 lastIndexOf()方法。都是从字符串中搜索传入的字符，返回字符对应的位置，并且都是找到第一个符合要求的字符就返回位置。(没查询到，则返回-1)。<b>两者的区别在于，indexOf()从头到尾进行查找，而 lastIndexOf()则是从尾部到头部进行查找。</b> 上面两个方法都可以接收一个可选的第二个参数，表示开始搜索的位置。<b>所以 indexOf()将会从指定位置开始向尾部进行搜索(忽略该指定位置之前的参数)，而 lastIndexOf()则会从指定位置开始从尾部向头部进行搜索(忽略该指定位置之后直到末尾的参数)。</b>\n\n​ startsWith()：用于从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。第一个参数为字符串必填参数，<b>传入后从索引为 0 开始搜索，搜索字符长度为传入字符串的长度。</b>接受第二个可选的参数，表示开始搜索的位置，忽略该位置之前的字符，但搜索范围同样是传入字符串的长度。\n\n​ includes()：接受参数与返回值与上方方法一致。<b>不同的是 includes 搜索范围是整个字符串。</b>\n\n​ endsWith()：接受参数与返回值与上方方法一致。搜索范围也与传入字符串长度有关。<b>但不同的是该方法检查开始与索引(string.length - substring.length)的匹配项。也就说检查开始与字符串长度减去传入字符串长度的索引位置。</b>也可以接收第二个可选的参数，<b>传入的第二个参数就代表字符串的总长度。所以会改变检查开始位置。</b>\n\n​ trim()：该方法会创建一个字符串副本，删除前，后所有空格符，再返回结果。返回的是一个字符串副本，愿字符串不受影响。trimLeft()、trimRight()分别清空字符串左右的空格。\n\n​ repeat()：这个方法接受一个整数参数，表示要将字符串复制多少次，然后拼接返回副本后的结果。\n\n​ `const stringValue = 'na';console.log(stringValue.repeat(16)); //nananananananananan...`\n\n​ padSatrt()和 padEnd()方法会复制字符串，小于指定长度，分别在左右填充字符，直至满足指定长度。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格。<b>第二个参数不限于一个字符 多个字符的字符串，会将其拼接并截断以匹配指定长度。如果第一个参数指定的长度小于或等于字符串长度，则返回原始字符串。</b>\n\n​ 字符串的迭代与解构：字符串在原型上暴露了一个@@iterator 方法。表示可以迭代字符串的每个字符。可以使用 for...of...进行循环，也可以通过解构操作符来进行解构。\n\n`let message = 'abcde';console.log([...message])//['a','b','c','d','e']`\n\n#### 4.单例内置对象\n\n##### Global\n\n​ Global 对象是 js 中最特别的对象，因为代码不会显式访问它。Global 对象是一种兜底对象，所针对的是不属于任何对象的属性和方法。在全局作用域中定义的变量和函数都会变成 Global 对象的属性。\n\n​ URL 编码方法\n\n​ encodeURI()：用于编码统一资源标识符。该方法在编码过程中不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号。所以该方法一般用于对整个 URL 进行编码。\n\n​ encodeURIComponent()：同样用于编码统一资源标识符。该方法会编码他发现的所有非标准字符。一般用于编码 URL 后面拼接的字符串。\n\n​ decodeURI()：仅对 encodeURI 编码后的字符进行解码。\n\n​ decodeURIComponent()：仅对 encodeURIComponent()编码后的字符进行解码。\n\n​ eval()：接受一个参数，是一个要执行的 js 字符串。\n\n```javascript\neval(\"console.log('hi')\");\n//等价于\nconsole.log(\"hi\");\n```\n\n1. 通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。\n2. 通过 eval()定义的任何变量和函数都不会被提升，解析代码的时候他们是被包含在一个字符串中，只是在 eval()执行的时候才会创建。\n\nwindow 对象\n\n​ js 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理。因此，所有全局作用域声明的变量和函数都变成了 window 对象的属性。下面展示另一种获取 Global 对象的方式\n\n```javaScript\nlet global=function(){\nreturn this;\n}\n```\n","tags":["JavaScript"]},{"title":"Es6-Class","url":"/blog/2023/02/27/Es6-Class/","content":"\n## class\n\n#### 1.基本含义，以及使用注意\n\n##### class 声明类的简单示例\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\nconst p = new Point(1, 2);\n```\n\n##### class 声明类的注意点\n\n1. 类中 this 关键字代表的是实例对象 即 this===p\n\n2. 在 class 里面声明方法不需要在前面加上 function，并且方法与方法之前不需要加逗号分隔，加了会报错\n\n3. class 声明的类 类型是 function，并且类本身就是指向 constructor\n\n4. 类本身是指向构造函数的，所以构造函数的 prototype 属性还是继续存在，并且实际上所有在类里面定义的方法都是定义在 prototype 上的，因此 在实例上调用方法，实际上是在调用原型上的方法\n\n5.类中定义的所有方法都是不可枚举的\n\n#### 2.constructor()方法\n\n1.一个类一定会有一个 constructor 方法，如果没有的话，会自动默认添加一个空的 constructor 方法\n\n2.constructor 会默认返回实例对象 即 this，也可以手动设置返回一个全新的对象\n\n3.类必须使用 new 关键字来调用，因为类的实际类型也是 Function，但与普通函数的区别就是 普通函数不需要 new 关键字来调用\n\n#### 3.类的实例\n\n```javascript\nclass Point {\n  //...\n}\n// 类的实例使用new关键字进行生成\nconst point = new Point();\n// 直接调用 Point() 会报错\n```\n\n1.类的属性和方法 除非显式定义在其本身(即在 this 对象上，类的实例上)，否则都是定义在其原型上(即定义在 class 上)\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x; //显式定义\n    this.y = y;\n  }\n  // 下面方法为定义到原型上\n  toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\n\nconst p1 = new Point(1, 2);\nconst p2 = new Point(3, 4);\n// 类的所有实例都是共享一个原型对象的\np1._proto_ === p2._proto_; //true\n// 上述代码因为p1和p2都是类Point的实例 所以他们的原型都是Point.prototype 所以_proto_属性是相等的\n```\n\n2.实例属性的新写法\n\n新写法就是可以将原本写在 constructor()方法中 this 上面的属性，写到类的最顶层\n\n```javascript\nclass Point {\n  _count = 0; // 新写法，不需要加this，依然是定义到类的实例上\n}\n```\n\n3.取值函数(getter)和存值函数(setter)\n\n在类的内部 对某个属性使用 get 和 set 关键字，可以对该属性进行取值和存值行为的拦截\n\n```javascript\nclass Point {\n  constructor() {}\n  get prop() {\n    // 对prop属性进行 取值操作拦截\n    return \"getter\";\n  }\n  set prop(value) {\n    // 对prop属性进行 存值操作拦截\n    return \"setter\" + value;\n  }\n}\nconst p1 = new Point();\nconsole.log((p1.prop = \"123\")); // 'setter123'\nconsole.log(p1.prop); // 'getter'\n```\n\n4.属性表达式\n\n类中定义属性的，可以采用表达式的形式\n\n#### 4.静态方法\n","tags":["Es6-Class"]}]