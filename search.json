[{"title":"基本引用类型","url":"/2023/03/02/基本引用类型/","content":"### 基本引用类型\n\n​\t引用值（或者对象）是某个特定引用类型的实例。\n\n​\t引用类型是把数据和功能组织到一起的结构。引用类型有时候也被称为是对象定义，因为他们描述了自己的对象应有的属性的方法。\n\n​\t新对象通过 new 操作符后跟一个构造函数来创建 例如：\n\n```javascript\n let now = new Date()\n // 上面 now这个变量保存的就是通过 new操作符 来创建的一个Date引用类型的实例\n```\n\n#### 1.Date\n\n​\t`let now = new Date()` 使用new操作符来调用Date构造函数创建一个日期对象\n\n​\t上述创建的日期对象保存的是当前的日期和时间。\n\n​\t如果需要基于其他时间进行创建 则需要将时间毫秒表示的参数传给Date构造函数，参数也可以是`Date.parse()`方法支持的日期格式，因为在Date构造函数会隐式调用`Date.parse()`,如果传入错误的参数 将会返回NaN。\n\n​\t`Date.UTC()`也是一个基于其他时间创建日期对象的一个方法。但是传入的参数很特殊，需要传入年、零起点月数（1月是0，2月是1，以此类推）、日（1~31）、时（0～23）、分、秒和毫秒。其中年、月为必填，其他参数没填 日默认为1，剩余参数默认为0。`Date.UTC()`也支持隐式调用，但是隐式调用返回的是本地日期，相反则返回的是GMT日期。该方法使用如下\n\n```javascript\n// GMT时间 2000年1月1日零点\nconst dateUtc = new Date(Date.UTC(2000,0))\n\n// GMT时间 2005年5月5日17时55分55秒\nconst dateUtc2 = new Date(Date.UTC(2005,4,5,17,55,55))\n\n// 本地时间 2000年1月1日零点\nconst dateUtc = new Date(2000,0)\n\n```\n\n​\t`Date.now()`方法返回执行时日期和时间的毫秒数 也就是时间戳\n\n​\t引用类型还重写了`toLocaleString()、toString()、valueOf()`方法\n\n#### 2.RegExp\n\n#### 3.原始值包装类型\n\n#### 4.单例内置对象\n\n\n\n\n\n","tags":["JavaScript"]},{"title":"Hello World","url":"/2023/03/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"Es6-Class","url":"/2023/02/27/Es6-Class/","content":"## class\n\n#### 1.基本含义，以及使用注意\n\n##### class声明类的简单示例\n\n```javascript\nclass Point{\n\tconstructor(x,y){\n\t\tthis.x=x;\n\t\tthis.y=y\n\t}\n\ttoString(){\n\t\treturn '('+ this.x +','+ this.y +')'\n\t}\n}\nconst p = new Point(1,2)\n```\n\n##### class声明类的注意点\n\n1.类中this关键字代表的是实例对象 即this===p\n\n2.在class里面声明方法不需要在前面加上function，并且方法与方法之前不需要加逗号分隔，加了会报错\n\n3.class声明的类 类型是function，并且类本身就是指向constructor\n\n4.类本身是指向构造函数的，所以构造函数的prototype属性还是继续存在，并且实际上所有在类里面定义的方法都是定义在prototype上的，因此 在实例上调用方法，实际上是在调用原型上的方法\n\n5.类中定义的所有方法都是不可枚举的\n\n#### 2.constructor()方法\n\n1.一个类一定会有一个constructor方法，如果没有的话，会自动默认添加一个空的constructor方法\n\n2.constructor会默认返回实例对象 即this，也可以手动设置返回一个全新的对象\n\n3.类必须使用new关键字来调用，因为类的实际类型也是Function，但与普通函数的区别就是 普通函数不需要new关键字来调用\n\n#### 3.类的实例\n\n```javascript\nclass Point\t{\n\t//...\n}\n// 类的实例使用new关键字进行生成\nconst point=new Point()\n// 直接调用 Point() 会报错\n```\n\n1.类的属性和方法 除非显式定义在其本身(即在this对象上，类的实例上)，否则都是定义在其原型上(即定义在class上)\n\n```javascript\nclass Point {\n\tconstructor(x,y){\n\t\tthis.x=x //显式定义 \n\t\tthis.y=y\n\t}\n\t// 下面方法为定义到原型上\n\ttoString(){\n\t\treturn '('+this.x+','+this.y+')'\n\t}\n}\n\nconst p1=new Point(1,2)\nconst p2=new Point(3,4)\n// 类的所有实例都是共享一个原型对象的\np1._proto_ === p2._proto_ //true\n// 上述代码因为p1和p2都是类Point的实例 所以他们的原型都是Point.prototype 所以_proto_属性是相等的\n```\n\n2.实例属性的新写法\n\n新写法就是可以将原本写在constructor()方法中this上面的属性，写到类的最顶层\n\n```javascript\nclass Point\t{\n\t_count=0; // 新写法，不需要加this，依然是定义到类的实例上\n}\n```\n\n3.取值函数(getter)和存值函数(setter)\n\n在类的内部 对某个属性使用get 和 set 关键字，可以对该属性进行取值和存值行为的拦截\n\n```javascript\nclass Point\t{\n\tconstructor(){}\n\tget prop(){\n    // 对prop属性进行 取值操作拦截\n\t\treturn 'getter'\n\t}\n\tset prop(value){\n    // 对prop属性进行 存值操作拦截\n\t\treturn 'setter'+value\n\t}\n}\nconst p1=new Point()\nconsole.log((p1.prop='123')) // 'setter123'\nconsole.log(p1.prop) // 'getter'\n```\n\n4.属性表达式\n\n类中定义属性的，可以采用表达式的形式\n\n#### 4.静态方法\n\n","tags":["Es6,Class"]},{"title":"javaScript","url":"/2023/02/17/javaScript/","tags":["demo"]}]